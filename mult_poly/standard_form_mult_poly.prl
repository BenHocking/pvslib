%-------------------------------------------
% @formula: Unif_cons 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
Unif_cons : PROOF
(spread (induct "p")
  ((then (skeep)(skeep)(expand Unif? 1)(skeep)
    (spread (case "i=0")
     ((then (flatten)(expand nth 2)(lift-if 2)
       (spread (split 2)
        ((then (flatten)(expand Unif? -3)
          (spread (inst -3 "0" "j-1")
           ((then (expand length 1)(assert))
            (then (assert)(expand length 1)(typepred "j")(expand length -1)(expand length -1)(assert))
            (then (expand nth -3)(assert)))))
         (then (flatten)))))
      (then (expand nth 2)(assert)(lift-if 2)
       (spread (split 2)
        ((then (flatten)(expand Unif? -2)(inst -2 "i-1" "j-1")(assert))
         (then (flatten)(expand nth 1)(lift-if 1)
          (spread (split 1)
           ((then (flatten)(expand Unif? -3)
             (spread (inst -3 "0" "i-1")
              ((then (expand length 1)(assert))
               (then (expand length 1)(assert)(typepred "i")(expand length -1)(expand length -1)(assert))
               (then (expand nth -3)(assert)))))
            (then (flatten)(assert))))))))
      (then (expand nth 1)(assert)(lift-if 1)(split 1)))))
   (then (assert))
   (then (assert))
   (then (assert))))
QED Unif_cons

%-------------------------------------------
% @formula: caretzero_every 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
caretzero_every : PROOF
(spread (induct "n")
  ((then (skeep)(expand ^ 1)(lemma "every_append[nat]")
    (spread (inst -1 "(LAMBDA (x: number): number_field_pred(x) AND real_pred(x) AND rational_pred(x) AND integer_pred(x) AND (x >= 0))" "(: 0 :)" "(: 0 :)^j")
     ((then (grind))
      (then (typepred "(: 0 :)")(assert)(grind)))))
   (then (expand ^)(assert)(grind))))
QED caretzero_every

%-------------------------------------------
% @formula: sum_nat 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
sum_nat : PROOF
(spread (induct "l")
  ((then (skeep)
    (spread (split 1)
     ((then (expand sum 1)(assert))
      (then (expand sum 1)(lemma integers.closed_plus)(typepred cons1_var)(assert)(inst?))
      (then (expand sum 1)(typepred cons1_var)(lemma rationals.closed_plus)(inst?)))))
   (then (expand sum)(assert))
   (then (expand sum))
   (then (lemma rationals.closed_plus)(expand sum))))
QED sum_nat

%-------------------------------------------
% @formula: sum_append 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
sum_append : PROOF
(spread (induct l1)
  ((then (skeep)(skeep)(expand sum 1 1)(assert)(lift-if 1)
    (spread (split 1)
     ((then (flatten)(lemma "car_append[nat]")(inst? -1)(replace -1)(assert)(lemma "cdr_append[nat]")(inst? -1)(replace -1)(assert)(expand sum 2 2)(inst? -3)(assert))
      (then (flatten)(lemma "length_append[nat]")(inst? -1)(expand length -1 1)(assert)(expand length -1 1)(assert)))))
   (then (skeep)(expand sum 1 1)(lift-if 1)
    (spread (split 1)
     ((then (flatten)(lemma "append_null_left[nat]")(inst? -1)(replace -1)(expand sum 2 3)(expand sum 2 2)(assert))
      (then (flatten)(lemma "append_null_left[nat]")(inst? -1)(replace -1)(expand sum 1)(assert)))))))
QED sum_append

%-------------------------------------------
% @formula: add_mono_commutative 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
add_mono_commutative : PROOF
(then (skeep)(expand add_mono))
QED add_mono_commutative

%-------------------------------------------
% @formula: term_deg_example 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
term_deg_example : PROOF
(then (eval-formula 1))
QED term_deg_example

%-------------------------------------------
% @formula: max_length_ex1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_length_ex1 : PROOF
(then (eval-formula 1))
QED max_length_ex1

%-------------------------------------------
% @formula: max_length_ex2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_length_ex2 : PROOF
(then (eval-formula 1))
QED max_length_ex2

%-------------------------------------------
% @formula: max_length_is_max 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_length_is_max : PROOF
(spread (induct "p")
  ((then (skeep)
    (spread (case "cons?(cons2_var) = FALSE")
     ((then (assert)(skeep)(expand nth 1)(lift-if 1)
       (spread (split 1)
        ((then (flatten 1)(assert)(inst -2 "j-1")(expand max_length 2)(assert))
         (then (expand max_length 1)(assert)(flatten 1)(assert)))))
      (then (skeep)(typepred "j")(expand length -1)(expand length -1)(assert)(expand nth 2)(expand max_length 2)(assert)))))
   (then (assert))
   (then (assert))))
QED max_length_is_max

%-------------------------------------------
% @formula: max_length_is_nth 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_length_is_nth : PROOF
(spread (induct "p")
  ((then (skeep)
    (spread (case "cons2_var=null")
     ((then (assert)(expand "max_length" 2 1)(expand "max" 2 1)(assert)
       (spread (case "length(cons1_var`alpha) < max_length(cons2_var)")
        ((then (assert)
          (spread (inst 3 "0")
           ((then (assert)(expand "length" 1 1)(assert))
            (then (expand "nth" 3 1)))))
         (then (skeep)
          (spread (inst 2 "j+1")
           ((then (assert)(expand "length" 1 1)(assert))
            (then (assert)(expand "nth" 2 1))))))))
      (then (assert)(hide -2)
       (spread (inst 1 "0")
        ((then (expand "length" 1 1)(assert))
         (then (expand "nth" 1)(grind))))))))
   (then (assert))
   (then (assert))))
QED max_length_is_nth

%-------------------------------------------
% @formula: max_length_Unif 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_length_Unif : PROOF
(then (skeep)(lemma "max_length_is_nth")(inst?)(skeep)(typepred "p")(inst -1 "j!1" "j")(assert))
QED max_length_Unif

%-------------------------------------------
% @formula: max_length_Unif_cdr 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_length_Unif_cdr : PROOF
(then (skeep)(typepred "p")(lemma "max_length_is_nth")(inst-cp  -1 "p")(inst -1 "cdr(p)")(skeep)(skeep)
  (spread (inst -3 "j+1" "j!1")
   ((then (expand "length" 1 1)(assert))
    (then (expand "nth" -3 1)(assert)))))
QED max_length_Unif_cdr

%-------------------------------------------
% @formula: max_length_a 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_length_a : PROOF
(spread (induct "p")
  ((then (skeep)(expand length 1 1)(expand "max_length" 1)(expand "length_a" 1)(expand max 1 1)(lift-if 1)
    (spread (split 1)
     ((then (flatten)(expand "max" 2 1)(assert)(assert)(flip-ineq 1)(mult-by -1 "length(cons2_var)")(assert))
      (then (flatten)(assert)(expand "max" 1 1)(assert)))))
   (then (grind))))
QED max_length_a

%-------------------------------------------
% @formula: lft_example1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_example1 : PROOF
(then (eval-formula 1))
QED lft_example1

%-------------------------------------------
% @formula: Lft_length 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
Lft_length : PROOF
(spread (induct "p")
  ((then (skeep)(skeep)(expand length 1 1)(expand lft 1)(lift-if 1)(assert)
    (spread (split)
     ((then (flatten)
       (spread (split 2)
        ((then (flatten)(expand length 2 2)(inst?))
         (then (flatten)(expand length 1 2)(inst?)))))
      (then (flatten)(assert)(expand length -1)(assert)))))
   (then (skeep)(expand lft)(assert))))
QED Lft_length

%-------------------------------------------
% @formula: max_length_lft 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_length_lft : PROOF
(spread (induct "p")
  ((then (skeep)(skeep)(expand lft 1)(lift-if 1)(assert)
    (spread (split 1)
     ((then (flatten)
       (spread (split 2)
        ((then (flatten)(expand max_length 2 2)(typepred "n")(assert))
         (then (flatten)(expand max_length 1 2)(lemma "length_append[nat]")
          (spread (inst?)
           ((then (assert))
            (then (replace -1)(lemma "length_appendn[nat]")
             (spread (inst?)
              ((then (assert))
               (then (replace -1)(expand length 1 2)(assert)))))))))))
      (then (flatten)(expand length -1)(assert)))))
   (then (skeep)(lemma "Lft_length")(inst?)(expand max_length 1)(expand length -1)(assert)(expand lft)(assert))))
QED max_length_lft

%-------------------------------------------
% @formula: lft_length_nth 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_length_nth : PROOF
(spread (induct "p")
  ((then (assert)(skeep)(skeep)(typepred "j")(lemma "Lft_length")(inst?)(replace -1))
   (then (assert)(skeep)(skeep)
    (spread (case "cons2_var = null")
     ((then (assert)(skeep)(expand lft 2)(lift-if)
       (spread (split 2)
        ((then (flatten)
          (spread (case "j=0")
           ((then (expand nth 3)(assert)(inst -1 "n")(inst -1 "j-1")(typepred "j")(expand length -1)(assert))
            (then (expand nth 2)(assert)(assert)(typepred "n")(expand max_length -1)(assert)))))
         (then (flatten)
          (spread (case "j=0")
           ((then (expand nth 2)(assert)(inst -3 "n")(inst -3 "j-1")(typepred "j")(expand length -1)(assert))
            (then (replace -1)(expand nth 1)(typepred "n")(expand max_length -1)(lemma "length_append[nat]")
             (spread (inst?)
              ((then (assert))
               (then (replace -1)(hide -1)(lemma "length_appendn[nat]")
                (spread (inst?)
                 ((then (assert))
                  (then (replace -1)(hide -1)(assert))))))))))))))
      (then (replace -1)(skeep)(typepred "j")(expand length -1)(expand length -1)(assert)(expand nth 1)(expand lft 1)(lift-if 1)
       (spread (split 1)
        ((then (flatten)(assert)(typepred "n")(expand max_length -1)(assert))
         (then (flatten)(lemma "length_append[nat]")
          (spread (inst?)
           ((then (typepred "n")(expand max_length -1)(expand max_length -1)(assert))
            (then (replace -1)(hide -1)(lemma "length_appendn[nat]")
             (spread (inst?)
              ((then (typepred "n")(replace -5)(expand max_length -1)(expand max_length -1)(assert))
               (then (replace -1)(hide -1)(expand length 1 2)(assert))))))))))))))
   (then (expand lft))
   (then (assert))))
QED lft_length_nth

%-------------------------------------------
% @formula: lft_Unif 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_Unif : PROOF
(then (skeep)
  (spread (case "p = null")
   ((then (expand Unif?)
     (spread (case "lft(p)(max_length(p)) = null")
      ((then (flatten)(skeep)(lemma "lft_length_nth")
        (spread (inst?)
         ((then (assert))
          (then (typepred "i")(lemma "Lft_length")(inst?)(replace -1))
          (then (replace -1)(lemma "lft_length_nth")
           (spread (inst -1 "p" "max_length(p)" "j")
            ((then (assert))
             (then (typepred "j")(lemma "Lft_length")(inst?)(replace -1))
             (then (replace -1))))))))
       (then (assert)))))
    (then (replace -1)(expand lft)(assert)(expand Unif?)))))
QED lft_Unif

%-------------------------------------------
% @formula: lft_n_last 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_n_last : PROOF
(spread (induct "p")
  ((then (skeep)(expand length -1)(lift-if -1)(assert))
   (then (skeep)(assert)(typepred "j")(lemma "Lft_length")(inst?)(assert))
   (then (skeep)(lemma "lft_length_nth")
    (spread (inst? -1)
     ((then (assert)(skeep)(typepred "n")(expand max_length)(grind))
      (then (expand length -1)(lift-if -1)(assert)))))
   (then (skeep)(skeep)
    (spread (case "j=0")
     ((then (expand nth 3)(assert)(expand lft 3)(assert)(expand nth -2)(inst -1 "n" "j-1")(assert))
      (then (replace -1)(expand nth -3)(hide 1)(expand lft 1)(assert)(expand nth 1)))))
   (then (grind))))
QED lft_n_last

%-------------------------------------------
% @formula: leq_reflexive 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
leq_reflexive : PROOF
(then (expand reflexive?)(expand leq)
  (spread (case " FORALL (m:nat, x: monomial): length(x`alpha)=m IMPLIES ((null?(x`alpha) AND null?(x`alpha)) OR cons?(x`alpha) AND cons?(x`alpha) AND leq((# C := x`C, alpha := cdr(x`alpha) #), (# C := x`C, alpha := cdr(x`alpha) #)))")
   ((spread (induct "m")
     ((then (hide 2)(skeep)(skeep)(expand length -2)(lift-if -2)
       (spread (split -2)
        ((then (flatten -1)(simplify -1)(inst -2 "(# C := x`C, alpha := cdr(x`alpha) #)")(assert)(assert)(expand leq 3))
         (then (flatten -1)(typepred j)(assert)))))
      (then (skeep)(hide 3)(expand length -1)(lift-if -1)
       (spread (split -1)
        ((then (flatten)(assert))
         (then (assert)))))))
    (then (skeep)(inst -1 "length(x`alpha)" "x")(assert)(grind)))))
QED leq_reflexive

%-------------------------------------------
% @formula: leq_transitive 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
leq_transitive : PROOF
(then (expand "transitive?" 1)
  (spread (case "FORALL (n:nat, x: monomial), (y: monomial), (z: monomial): length(x`alpha)=n IMPLIES ( leq(x, y) & leq(y, z) => leq(x, z))")
   ((then (hide 2)
     (spread (induct "n")
      ((then (skeep)(skeep)
        (spread (case "NOT length(x`alpha) = length(y`alpha)")
         ((then (expand "leq" -4)(assert)
           (spread (case "length(y`alpha)< length(z`alpha)")
            ((then (assert)(expand "leq" 2 1)(flatten)
              (spread (case "NOT length(y`alpha) = length(z`alpha)")
               ((then (assert)(expand "leq" -6)(assert)
                 (spread (case "sum(x`alpha) < sum(y`alpha)")
                  ((then (assert)
                    (spread (case "sum(x`alpha) = sum(y`alpha)")
                     ((then (assert))
                      (then (assert)
                       (spread (case "(sum(y`alpha) = sum(z`alpha))")
                        ((then (assert))
                         (then (assert)
                          (spread (case "car(x`alpha) < car(y`alpha)")
                           ((then (assert)
                             (spread (case "car(x`alpha) = car(y`alpha)")
                              ((then (assert))
                               (spread (case "car(y`alpha) < car(z`alpha)")
                                ((then (assert)(flatten)(assert)(inst -6 "(# C := x`C, alpha := cdr(x`alpha) #)" "(# C := y`C, alpha := cdr(y`alpha) #)" "(# C := z`C, alpha := cdr(z`alpha) #)")(assert)(expand "length" -6))
                                 (then (flatten)(assert)))))))
                            (spread (case "car(y`alpha) < car(z`alpha)")
                             ((spread (case "car(y`alpha) = car(z`alpha)")
                               ((then (assert))
                                (then (assert))))
                              (then (assert)))))))))))))
                   (spread (case "sum(y`alpha) < sum(z`alpha)")
                    ((then (assert))
                     (then (assert)))))))
                (then (assert)(expand "leq" -5)))))
             (then (assert)(expand "leq" 1 1)))))
          (then (expand "leq" -3)(assert)(expand "leq" -4)
           (spread (case "length(y`alpha) < length(z`alpha)")
            ((then (assert)
              (spread (case "NOT length(y`alpha) = length(z`alpha)")
               ((then (assert)(expand "leq" 3))
                (then (assert)))))
             (then (assert)(expand "leq" 2))))))))
       (then (skeep)
        (spread (case "length(x`alpha) = length(y`alpha)")
         ((then (expand "leq" -2)(assert)(hide -2)(expand "leq" 2)(expand "leq" -2)(flatten)(assert))
          (spread (case "length(z`alpha) = length(y`alpha)")
           ((then (assert)(expand "leq" 2 1))
            (then (expand "length" -)(lift-if)(assert)(lift-if)
             (spread (split)
              ((then (flatten)(assert)(lift-if)
                (spread (split)
                 ((then (flatten)(assert))
                  (then (flatten)(split))
                  (then (flatten)(assert)(split))
                  (then (flatten)(assert)))))
               (then (assert)(flatten)(assert)(lift-if)
                (spread (split)
                 ((then (flatten)(assert))
                  (then (assert)
                   (spread (split)
                    ((then (flatten)(assert))
                     (then (expand "leq")(flatten)))))))))))))))))))
    (then (skeep)(inst -1 "length(x`alpha)" "x" "y" "z")(assert)))))
QED leq_transitive

%-------------------------------------------
% @formula: leq_dichotomous 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
leq_dichotomous : PROOF
(then (expand dichotomous?)
  (spread (case "FORALL (n:nat, x: monomial), (y: monomial): (length(x`alpha) =n) IMPLIES (leq(x, y) OR leq(y, x))")
   ((then (hide 2)
     (spread (induct "n")
      ((then (skeep)(skeep)(expand "leq" +)(flatten)(assert)
        (spread (case "NOT length(y`alpha) = length(x`alpha)")
         ((then (assert)(assert)(hide 2 7)(inst -2 "(# C := y`C, alpha := cdr(y`alpha) #)" "(# C := x`C, alpha := cdr(x`alpha) #)")(assert)(expand "length" -1)(expand "length" -2)(assert))
          (then (assert)))))
       (then (skeep)(expand "leq" 1)(assert)
        (spread (case "length(y`alpha)=0")
         ((then (assert))
          (then (assert)(expand "length" -)(lift-if -1)
           (spread (split -1)
            ((then (flatten)(assert))
             (then (flatten)(lift-if -2)
              (spread (split -2)
               ((then (flatten)(assert))
                (then (assert))))))))))))))
    (then (skeep)(inst -1 "length(x`alpha)" "x" "y")(assert)))))
QED leq_dichotomous

%-------------------------------------------
% @formula: almost_total_order 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
almost_total_order : PROOF
(spread (case "FORALL (n:nat, m1, m2: monomial): length(m1`alpha) = n IMPLIES ( leq(m1, m2) AND leq(m2, m1) IMPLIES m1`alpha = m2`alpha)")
  ((then (hide 2)
    (spread (induct "n")
     ((then (flatten)(expand leq -3)(expand leq -4)
       (spread (split -3)
        ((then (flatten)(assert)(inst -8 "(# C := m1`C, alpha := cdr(m1`alpha) #)" "(# C := m2`C, alpha := cdr(m2`alpha) #)")(assert)(hide -6)(hide -8)(hide -6)
          (spread (case "FORALL(l1,l2:list[nat]): cons?(l1) AND cons?(l2) IMPLIES (car(l1)=car(l2) AND cdr(l1) = cdr(l2))  IMPLIES l1=l2")
           ((then (hide-all-but 1)(skeep)(lemma "list_extensionality[nat]")(inst -1 "l1" "l2")(assert)(expand length 1)(skeep)
             (spread (case "n=0")
              ((then (expand nth 2)(assert))
               (then (expand nth 1)(assert)))))
            (then (inst -1 "m1`alpha" "m2`alpha")(assert)))))
         (then (flatten)(assert))
         (then (assert)(flatten)(assert))
         (then (assert))
         (then (assert)))))
      (then (skeep)(skeep)(expand length -2)(lift-if -2)(assert)(split -2))
      (then (skeep)(expand length -1)(lift-if)
       (spread (split -1)
        ((then (flatten)(assert))
         (then (expand leq)(assert)(flatten)
          (spread (split -2)
           ((then (flatten)(assert))
            (then (assert)))))))))))
   (then (skeep)(inst -1 "length(m1`alpha)" "m1" "m2")(assert))))
QED almost_total_order

%-------------------------------------------
% @formula: leq_total_preorder 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
leq_total_preorder : PROOF
(then (expand total_preorder?)(lemma "leq_dichotomous")(assert)(expand preorder?)(lemma "leq_reflexive")(lemma "leq_transitive")(assert))
QED leq_total_preorder

%-------------------------------------------
% @formula: mv_sort_ex1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
mv_sort_ex1 : PROOF
(then (eval-formula 1))
QED mv_sort_ex1

%-------------------------------------------
% @formula: mv_sort_is_sorted 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
mv_sort_is_sorted : PROOF
(then (skeep)(expand mv_sort)
  (spread (split)
   ((then (flatten)(lemma bubblesort_is_sorted)(inst?))
    (then (expand is_sorted?)(assert)))))
QED mv_sort_is_sorted

%-------------------------------------------
% @formula: cons_smaller_to_sorted_is_sorted 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
cons_smaller_to_sorted_is_sorted : PROOF
(then (skeep)(expand is_sorted?)(skeep)
  (spread (case "k=0")
   ((then (expand nth 2)(assert)(inst -2 "k-1")(expand length -4)(assert))
    (then (replace -1)(expand nth 1)(expand nth 1)))))
QED cons_smaller_to_sorted_is_sorted

%-------------------------------------------
% @formula: add_mono_sorted 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
add_mono_sorted : PROOF
(then (skeep)(expand is_sorted? 1)(skeep)
  (spread (case "k=0")
   ((then (expand nth 2)(assert)(expand is_sorted? -2)(inst -2 "k-1")(expand length -4)(assert))
    (then (replace -1)(expand nth 1)(expand nth 1)))))
QED add_mono_sorted

%-------------------------------------------
% @formula: constant_doesnt_matter 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
constant_doesnt_matter : PROOF
(spread (case "FORALL (n:nat, m1, m2, m3: monomial): length(m1`alpha) = n  IMPLIES ( leq(m1, m3) AND m1`alpha = m2`alpha IMPLIES leq(m2, m3))")
  ((then (hide 2)
    (spread (induct "n")
     ((then (skeep)(skeep)(expand "leq" -3)(expand "leq" 1)(flatten)(assert)
       (spread (split -3)
        ((then (flatten)(assert)(replace -8)(assert)(inst -6 "(# C := m1`C, alpha := cdr(m1`alpha) #)" "(# C := m2`C, alpha := cdr(m2`alpha) #)" "(# C := m3`C, alpha := cdr(m3`alpha) #)")(assert)(expand "length" -6)(reveal -)(hide -1 -2)(assert))
         (then (flatten)(assert))
         (then (flatten)(replace -5)(assert)))))
      (then (skeep)(assert)(expand "leq" 1 1)(replace -3 -1)(replace -3 -1 rl)(replace -3 -1)(expand "length" -1)(lift-if -1)
       (spread (split -1)
        ((then (flatten)(assert))
         (then (flatten)(assert)(expand "length" 1 1)(expand "length" 1 1)(assert))))))))
   (then (skeep)(inst -1 "length(m1`alpha)" "m1" "m2" "m3")(assert))))
QED constant_doesnt_matter

%-------------------------------------------
% @formula: constant_doesnt_matter_last 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
constant_doesnt_matter_last : PROOF
(spread (case "FORALL (n:nat,m1, m2, m3: monomial): (length(m1`alpha) = n AND leq(m1, m2) AND m2`alpha = m3`alpha) IMPLIES leq(m1, m3)")
  ((then (hide 2)
    (spread (induct "n")
     ((then (flatten)(hide 1)(hide 1)(hide 1)(assert)(inst -6 "(# C := m1`C, alpha := cdr(m1`alpha) #)" "(# C := m2`C, alpha := cdr(m3`alpha) #)" "(# C := m3`C, alpha := cdr(m3`alpha) #)")(expand length -7)(assert))
      (then (skeep)(skeep)(expand leq -3)(expand leq 1)(replace -4)(assert)(flatten)(assert)(split -3))
      (then (skeep)(expand length -1)(lift-if -1)
       (spread (split -1)
        ((then (flatten)(assert))
         (then (expand leq 1)(assert)(split expand length 1)(flatten)(assert)(expand length 1)(assert))))))))
   (then (skeep)(inst -1 "length(m1`alpha)" "m1" "m2" "m3")(assert))))
QED constant_doesnt_matter_last

%-------------------------------------------
% @formula: append_leq 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
append_leq : PROOF
(spread (case "FORALL (n:nat,l: list[nat], m1: monomial,m2: {mm: monomial | length(m1`alpha) = length(mm`alpha)}): LET M1: [# alpha: list[nat], C: real #] = (# C := m1`C, alpha := append(m1`alpha, l) #), M2: [# alpha: list[nat], C: real #] = (# C := m2`C, alpha := append(m2`alpha, l) #) IN length(m1`alpha) =n AND leq(m1, m2) IMPLIES leq(M1, M2)")
  ((then (hide 2)
    (spread (induct "n")
     ((then (skeep)(skeep)(expand length -2)(lift-if -2)
       (spread (split -2)
        ((then (flatten)(assert)(typepred "m2")(expand leq -4)
          (spread (split -4)
           ((then (expand leq 2)(flatten)(hide 2)(hide 2)(hide 2)(hide 2)(lemma "length_append[nat]")(lemma "length_append[nat]")(inst -1 "m1`alpha" "l")(replace -1)(expand length -1 2)(expand length -1 1)(lift-if -1)
             (spread (split -1)
              ((then (flatten)(assert)(hide -1)(inst -1 "m2`alpha" "l")(replace -1)(assert)(expand length -1 2)(expand length -1 1)(lift-if)
                (spread (split -1)
                 ((then (flatten)(assert)(hide -1)(lemma "sum_append")(lemma "sum_append")(inst? -1)(replace -1)(hide -1)(inst -1 "m2`alpha" "l")(replace -1)(hide -1)(assert)(lemma "car_append[nat]")(lemma "car_append[nat]")(inst? -1)(replace -1)(hide -1)(inst -1 "l" "m1`alpha")(replace -1)(assert)(hide -1)(lemma "cdr_append[nat]")(lemma "cdr_append[nat]")(inst? -1)(replace -1)(hide -1)(inst -1 "l" "m2`alpha")(replace -1)(hide -1)
                   (spread (inst -7 "l" "(# C := m1`C, alpha := cdr(m1`alpha) #)" "(# C := m2`C, alpha := cdr(m2`alpha) #)")
                    ((then (typepred "m2")(expand length -1))
                     (then (assert)))))
                  (then (assert)(flatten)(assert)))))
               (then (flatten)(assert)))))
            (then (expand leq 2)(flatten)(lemma "length_append[nat]")(inst? -1)(replace -1)(hide -1)(lemma "length_append[nat]")(inst -1 "m2`alpha" "l")(replace -1)(assert)(hide -1)(replace -4)(assert)(lemma "sum_append")(lemma "sum_append")(inst? -1)(replace -1)(hide -1)(inst -1 "m2`alpha" "l")(replace -1)(hide -1)(assert)(replace -1)(lemma "car_append[nat]")(lemma "car_append[nat]")(inst? -1)(replace -1)(hide -1)(inst -1 "l" "m2`alpha")(replace -1)(assert)(hide 6)(hide 4)(hide 2)(hide 2)(lemma "length_append[nat]")(inst? -1)(expand length -1 2)(expand length -1 1)(lift-if -1)
             (spread (split -1)
              ((then (flatten)(hide -1)(assert)(lemma "length_append[nat]")(inst -1 "m1`alpha" "l")(expand length -1 2)(expand length -1 1)(lift-if -1)
                (spread (split -1)
                 ((then (flatten)(assert))
                  (then (flatten)(assert)))))
               (then (flatten)(assert)))))
            (then (expand leq 2)(lemma "sum_append")(inst? -1)(lemma "length_append[nat]")(inst? -1)(replace -1)(lemma "length_append[nat]")(inst -1 "m2`alpha" "l")(replace -1)(assert)(hide -1)(hide -1)(replace -1)(hide -1)(lemma "sum_append")(inst -1 "m2`alpha" "l")(replace -1)(hide -1)(expand sum 2 2)(flatten)(lift-if 3)
             (spread (split 3)
              ((then (flatten)(expand sum 2 4)(assert))
               (then (flatten)(expand sum 1 3)(assert))))))))
         (then (flatten)(assert)))))
      (spread (induct "l")
       ((then (skeep)(skeep)(expand length -2)(lift-if -2)
         (spread (split -2)
          ((then (flatten)(assert))
           (then (typepred "m2")(expand length -1)(assert)(lift-if -1)
            (spread (split -1)
             ((then (flatten)(assert))
              (then (lemma "append_null_left[nat]")(inst -1 "cons(cons1_var,cons2_var)")
               (spread (case "m1`alpha = (: :) AND m2`alpha = (: :)")
                ((then (assert))
                 (then (flatten)(replace -1)(replace -2)(replace -3)(hide -1)(hide -1)(hide -1)(hide -1)(hide -1)(expand leq 1)(inst -1 "(# C := m1`C, alpha := (: :) #)" "(# C := m2`C, alpha := (: :) #)")(expand length -1)(expand leq -1 1)(lemma "append_null_left[nat]")(inst -1 "cons2_var")(replace -1)))))))))))
        (then (skeep)(lemma "append_null_right[nat]")(lemma "append_null_right[nat]")(inst? -1)(replace -1)(inst -2 "m2`alpha")(replace -2)(expand leq))))
      (then (skeep)(inst? -1)(assert)))))
   (then (skeep)(inst -1 "length(m1`alpha)" "l" "m1" "m2"))))
QED append_leq

%-------------------------------------------
% @formula: simplify_cdr 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
simplify_cdr : PROOF
(then (skeep)(typepred "p")(expand simplified?)
  (spread (split 1)
   ((then (flatten)
     (spread (split 3)
      ((then (skeep)
        (spread (split -3)
         ((then (flatten)
           (spread (split -1)
            ((spread (inst -1 "i+1" "j+1")
              ((then (expand length 1)(assert))
               (then (expand length 1)(assert))
               (then (assert)(expand nth 1)))))))
          (then (expand length -1)(assert)))))))))))
QED simplify_cdr

%-------------------------------------------
% @formula: simplify_cons 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
simplify_cons : PROOF
(spread (case "FORALL (n:nat, p: MultPoly | is_sorted?(p)): length(p) = n AND cons?(p) IMPLIES cons?(sortedsimplify(p))")
  ((then (hide 2)
    (spread (induct "n")
     ((then (lemma "leq_total_preorder"))
      (then (skeep)(assert)(lemma "leq_total_preorder"))
      (then (skeep)(skeep)(expand sortedsimplify 1)(lift-if 1)
       (spread (split)
        ((then (flatten)
          (spread (split)
           ((then (flatten)
             (spread (split 2)
              ((then (flatten)(assert))
               (then (flatten)(inst -2 "cons(add_mono(car(p), car(cdr(p))),cdr(cdr(p)))")(expand length -2)(expand length -3)(assert)(expand length -2)))))
            (then (assert)))))
         (then (assert)))))
      (then (skeep)(expand length -1)(lift-if -1)
       (spread (split)
        ((then (flatten)(assert))
         (then (assert))))))))
   (then (skeep)(inst -1 "length(p)" "p")(assert))))
QED simplify_cons

%-------------------------------------------
% @formula: leq_simplify 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
leq_simplify : PROOF
(spread (case "FORALL (n:nat, p: MultPoly | cons?(p) AND is_sorted?(p), m: monomial): length(p) = n AND leq(m, car(p)) IMPLIES leq(m, car(sortedsimplify(p)))")
  ((then (hide 2)
    (spread (induct "n")
     ((then (skeep)(lemma "leq_total_preorder"))
      (then (skeep)(lemma "simplify_cons")(inst -1 "p")(assert))
      (then (skeep)(lemma "leq_total_preorder"))
      (then (skeep)(assert)(lemma "simplify_cons")(inst -1 "p")(assert))
      (then (skeep)(skeep)(expand sortedsimplify 1)(lift-if 1)
       (spread (split 1)
        ((then (flatten)
          (spread (split 2)
           ((then (flatten))
            (then (flatten)(expand length -3)(expand length -3)(assert)
             (spread (inst -2 "cons(add_mono(car(p), car(cdr(p))),cdr(cdr(p)))" "m")
              ((then (typepred "p")(hide -1)(lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert)(lemma "cdr_of_sorted_is_sorted")(inst -1 "cdr(p)")(assert)(lemma "cons_smaller_to_sorted_is_sorted")
                (spread (case "cdr(cdr(p))=null")
                 ((then (inst -1 "cdr(cdr(p))" "add_mono(car(p),car(cdr(p)))")(assert)(expand add_mono 2)(replace -4)(expand is_sorted? -2)
                   (spread (inst -2 "0")
                    ((then (expand length 1)(assert))
                     (then (expand length -2)(expand length -2)(expand nth -2)(expand nth -2)(assert)(assert)(lemma "constant_doesnt_matter")(inst -1 "car(cdr(p))" "(# C := car(cdr(p))`C + car(p)`C, alpha := car(cdr(p))`alpha #)" "car(cdr(cdr(p)))")(assert)))))
                  (then (replace -1)(expand is_sorted? 1)(skeep)(typepred "k")(expand length -1)(assert)))))
               (then (expand length -2)(expand add_mono 3)(lemma "constant_doesnt_matter_last")(inst -1 "m" "car(p)" "(# C := car(cdr(p))`C + car(p)`C, alpha := car(p)`alpha #)")(assert))))))))
         (then (assert)))))
      (then (skeep)(expand length -1)(assert)))))
   (then (skeep)(inst -1 "length(p)" "p" "m")(assert))))
QED leq_simplify

%-------------------------------------------
% @formula: sorted_simp_is_sorted 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
sorted_simp_is_sorted : PROOF
(spread (case "FORALL (n:nat,p: MultPoly | is_sorted?(p)): length(p) = n IMPLIES is_sorted?(sortedsimplify(p)) = TRUE")
  ((then (hide 2)
    (spread (induct "n")
     ((then (lemma "leq_total_preorder"))
      (then (skeep)(lemma "leq_total_preorder"))
      (then (lemma "leq_total_preorder"))
      (then (skeep)(lemma "leq_total_preorder"))
      (then (flatten)
       (spread (split 2)
        ((then (flatten)(typepred "p")(lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert)(expand length -4)(inst -3 "cdr(p)")(assert)(lemma "leq_simplify")(inst -1 "cdr(p)" "car(p)")(expand is_sorted? -3)(inst -3 "0")(expand length -3)(expand length -3)(expand nth -3)(expand nth -3)(expand length -3)(lift-if -3)
          (spread (split -3)
           ((then (flatten)(assert)(assert)(lemma "simplify_cons")(inst -1 "cdr(p)")(assert)(lemma "cons_smaller_to_sorted_is_sorted")(inst -1 "sortedsimplify(cdr(p))" "car(p)")(assert))
            (then (flatten)(assert)(lemma "cons_smaller_to_sorted_is_sorted")(lemma "simplify_cons")(inst -1 "cdr(p)")(assert)(inst -2 "sortedsimplify(cdr(p))" "car(p)")(assert)))))
         (then (flatten)(lemma "add_mono_sorted")
          (spread (case "cdr(cdr(p)) = null")
           ((then (inst -1 "cdr(cdr(p))" "car(p)" "car(cdr(p))")(assert)(lemma "cdr_of_sorted_is_sorted")(inst? -1)(assert)(lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert)(expand add_mono -3 1)(replace -4)(lemma "constant_doesnt_matter")(inst -1 "car(cdr(p))" "(# C := car(cdr(p))`C + car(p)`C, alpha := car(cdr(p))`alpha #)" "car(cdr(cdr(p)))")(expand is_sorted? -2)
             (spread (inst -2 "0")
              ((then (expand length 1)(assert))
               (then (expand length -2)(expand length -2)(assert)(expand nth -2)(expand nth -2)(assert)(inst -6 "cons(add_mono(car(p), car(cdr(p))), cdr(cdr(p)))")(expand length -7)(expand length -6)(expand length -6)))))
            (then (replace -1)(expand sortedsimplify 1)(expand is_sorted? 1)(skeep)(typepred "k")(expand length -1)(assert))))))))
      (then (flatten)(split 2))
      (then (skeep)(skeep)(expand sortedsimplify 1)(assert)(split 1))
      (then (skeep)(expand length -1)(lift-if)
       (spread (split)
        ((then (flatten)(assert))
         (then (expand sortedsimplify)(assert))))))))
   (then (skeep)(inst -1 "length(p)" "p"))))
QED sorted_simp_is_sorted

%-------------------------------------------
% @formula: cons_smaller_simplify 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
cons_smaller_simplify : PROOF
(spread (induct "p")
  ((then (skeep)(lemma "leq_total_preorder"))
   (then (skeep)
    (spread (case "cons2_var = null")
     ((then (skeep)(typepred "i")(typepred "j")(expand length)(expand length)
       (spread (case "i=0")
        ((then (expand nth -3)(assert)(lift-if -3)
          (spread (split -3)
           ((then (flatten)(expand simplified? -6)(expand length -6)(expand length -6)(assert)
             (spread (split -6)
              ((then (flatten)(hide 1)
                (spread (split -1)
                 ((then (inst -1 "i-1" "j-1")(assert)))))
               (then (assert)))))
            (then (flatten)(expand nth -2)(lift-if -2)
             (spread (split -2)
              ((then (flatten)(lemma "cdr_of_sorted_is_sorted")(inst -1 "cons(cons1_var,cons2_var)")(assert)(lemma "simplify_cdr")(inst -1 "cons(cons1_var,cons2_var)")(assert)(inst -7 "m")(expand is_sorted? -8)
                (spread (inst -8 "0")
                 ((then (expand length 1)(assert))
                  (then (assert)(expand length -8)(expand nth -8)(expand nth -8)(lemma "leq_transitive")(expand transitive? -1)(inst -1 "m" "cons1_var" "car(cons2_var)")(assert)
                   (spread (case "m`alpha = car(cons2_var)`alpha")
                    ((then (assert)(expand simplified? -8)(expand length -8)
                      (spread (split -8)
                       ((spread (inst -1 "0" "i-1")
                         ((then (expand length 1)(assert))
                          (then (expand length 1)(assert))
                          (then (assert)(expand nth -1)(assert)))))))
                     (then (lemma "constant_doesnt_matter")(inst -1 "m" "car(cons2_var)" "cons1_var")(assert)(lemma "almost_total_order")(inst -1 "car(cons2_var)" "cons1_var")(assert))))))))
               (then (flatten)(assert))))))))
         (then (replace -1)(expand nth -4)(assert)(expand nth -4)(lift-if -4)
          (spread (split -4)
           ((then (flatten)(lemma "cdr_of_sorted_is_sorted")(inst -1 "cons(cons1_var,cons2_var)")(assert)(lemma "simplify_cdr")(inst -1 "cons(cons1_var,cons2_var)")(assert)(inst -7 "m")(expand is_sorted? -8)
             (spread (inst -8 "0")
              ((then (expand length 1)(assert))
               (then (expand length -8)(expand nth -8)(expand nth -8)(assert)(lemma "leq_transitive")(expand transitive? -1)(inst? -1)(inst -1 "cons1_var")(assert)(expand simplified? -10)(expand length -10)
                (spread (split -10)
                 ((spread (inst -1 "0" "1")
                   ((then (expand length 1)(assert))
                    (then (expand length 1)(assert))
                    (then (assert)(expand nth -1)(expand nth 1)(assert)
                     (spread (case "m`alpha = car(cons2_var)`alpha")
                      ((then (assert)(expand simplified? -8)(expand length -8)
                        (spread (split -8)
                         ((spread (inst -1 "0" "j-1")
                           ((then (expand length 1)(assert))
                            (then (expand length 1)(assert))
                            (then (assert)(expand nth -1)))))))
                       (then (replace -1)(lemma "constant_doesnt_matter")(inst -1 "m" "car(cons2_var)" "cons1_var")(assert)(lemma "almost_total_order")(inst -1 "cons1_var" "car(cons2_var)")(assert)))))))))))))
            (then (flatten))))))))
      (then (flatten)(hide 1)(split 1))
      (then (skeep)(typepred "i")(typepred "j")(expand length)(expand length)(assert)
       (spread (case "i=0")
        ((then (flatten)(assert))
         (then (expand nth -3)(assert)(lift-if -3)
          (spread (split -3)
           ((then (flatten)(assert))
            (then (flatten)(assert)(expand nth -2)(assert)))))
         (then (replace -1)(expand nth)(assert)(expand nth -4)(lift-if -4)(assert)(split -4)))))
      (then (flatten)(hide 1)(split 1))
      (then (assert)(skeep)(expand simplified? 3)(expand length 3)(assert)(expand length 3)(split 3))
      (then (replace -1)(skeep)(expand simplified? 2)(expand length 2)(expand length 2)(split 2)))))
   (then (assert))
   (then (assert))
   (then (assert))
   (then (assert))))
QED cons_smaller_simplify

%-------------------------------------------
% @formula: cons_simplify 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
cons_simplify : PROOF
(then (skeep)(typepred "p")(expand simplified? 1)(expand length 1)(expand length 1)(assert)
  (spread (split 1)
   ((then (flatten)
     (spread (split 2)
      ((then (skeep)
        (spread (case "i=0")
         ((spread (case "j=0")
           ((then (expand nth -1)(assert)(expand simplified? -3)(assert)
             (spread (split -3)
              ((then (flatten)
                (spread (split -1)
                 ((then (inst -1 "i-1" "j-1")(assert)))))
               (then (assert)(typepred "i")(expand length -1)(replace -2)(assert)(typepred "j")(expand length -1)(replace -3)(assert)))))
            (then (expand nth -2)(assert)(inst -5 "i-1")(assert))))
          (then (expand nth -2)(assert)(inst -5 "j-1")(assert)))))))))))
QED cons_simplify

%-------------------------------------------
% @formula: car_equal_simplify 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
car_equal_simplify : PROOF
(spread (case "FORALL (n:nat, p: MultPoly | cons?(p) AND is_sorted?(p)): length(p) = n IMPLIES car(p)`alpha = car(sortedsimplify(p))`alpha")
  ((then (hide 2)
    (spread (induct "n")
     ((then (skeep)(lemma "leq_total_preorder"))
      (then (skeep)(lemma "simplify_cons")(inst -1 "p")(assert))
      (then (skeep)(lemma "leq_total_preorder"))
      (then (skeep)(lemma "simplify_cons")(inst -1 "p")(assert))
      (then (flatten)
       (spread (split 2)
        ((then (flatten)(lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert)(lemma "cdr_of_sorted_is_sorted")(inst -1 "cdr(p)")(assert)(lemma "cons_smaller_to_sorted_is_sorted")
          (spread (case "cdr(cdr(p)) = null")
           ((then (inst -1 "cdr(cdr(p))" "add_mono(car(p),car(cdr(p)))")(assert)(expand add_mono -1 1)(expand is_sorted? -3)
             (spread (inst -3 "0")
              ((then (expand length 1)(assert))
               (then (expand nth -3)(expand nth -3)(expand length -3)(expand length -3)(assert)
                (spread (split -3)
                 ((then (expand length 1)(lift-if 1)
                   (spread (split 1)
                    ((then (flatten)(assert))
                     (then (assert)))))
                  (then (replace -4)(lemma "constant_doesnt_matter")(inst -1 "car(cdr(p))" "(# C := car(cdr(p))`C + car(p)`C, alpha := car(cdr(p))`alpha #)" "car(cdr(cdr(p)))")(assert)(hide -1)(inst -5 "cons(add_mono(car(p), car(cdr(p))), cdr(cdr(p)))")(expand length -5)(expand length -6)(assert)(expand add_mono -5 1)(replace -4))))))))
            (then (replace -1)(expand sortedsimplify 1)(expand add_mono 1))))))))
      (then (skeep)(skeep)(expand length -2)(expand sortedsimplify 1)(lift-if 1)(split 1))
      (then (skeep)(expand length -1 )(assert)))))
   (then (skeep)(inst -1 "length(p)" "p"))))
QED car_equal_simplify

%-------------------------------------------
% @formula: not_equal_simplify 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
not_equal_simplify : PROOF
(then (skeep)(expand sortedsimplify -1)(lift-if -1)
  (spread (split -1)
   ((then (flatten)
     (spread (split -1)
      ((then (flatten))
       (then (flatten)(lemma "car_equal_simplify")(typepred "p")(lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert)(lemma "cdr_of_sorted_is_sorted")(inst -1 "cdr(p)")(assert)
        (spread (case "cdr(cdr(p)) = null")
         ((then (lemma "cons_smaller_to_sorted_is_sorted")(inst -1 "cdr(cdr(p))" "add_mono(car(p),car(cdr(p)))")(assert)(expand add_mono -1 1)(lemma "constant_doesnt_matter")(expand is_sorted? -4)
           (spread (inst -4 "0")
            ((then (expand length 1)(assert))
             (spread (split -4)
              ((then (expand length 1)(expand length 1)(expand length 1)(lift-if 1)
                (spread (split 1)
                 ((then (assert)(flatten)(assert))
                  (then (assert)))))
               (then (expand nth -1)(expand nth -1)(replace -8)(inst -2 "car(cdr(p))" "(# C := car(cdr(p))`C + car(p)`C, alpha := car(cdr(p))`alpha #)" "car(cdr(cdr(p)))")(assert)(hide -1)(hide -1)(inst -5 "cons(add_mono(car(p), car(cdr(p))), cdr(cdr(p)))")(assert)(expand add_mono -5 1)(replace -6)(replace -5)))))))
          (then (replace -1)(expand sortedsimplify -8)(expand add_mono -8))))))))
    (then (flatten)))))
QED not_equal_simplify

%-------------------------------------------
% @formula: simplify_alpha 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
simplify_alpha : PROOF
(spread (case "FORALL (n:nat,p: MultPoly | cons?(p) AND is_sorted?(p)): length(p) = n IMPLIES (FORALL (j: below(length(sortedsimplify(p)))): EXISTS (i: below(length(p))): nth(p, i)`alpha = nth(sortedsimplify(p), j)`alpha)")
  ((then (hide 2)
    (spread (induct "n")
     ((then (skeep)(lemma "leq_total_preorder"))
      (then (skeep)(lemma "leq_total_preorder"))
      (then (skeep)(skeep)(expand length -2)(skeep)(expand sortedsimplify 1)
       (spread (case "cdr(p) = null")
        ((then (assert)
          (spread (case "car(p)`alpha = car(cdr(p))`alpha")
           ((then (assert)(expand nth 3 2)
             (spread (case "j=0")
              ((then (assert)
                (spread (inst -1 "cdr(p)")
                 ((then (assert)(typepred "p")(lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert))
                  (then (assert)
                   (spread (inst -1 "j-1")
                    ((then (typepred "j")(expand sortedsimplify -1)(expand length -1)(assert))
                     (then (skeep)
                      (spread (inst 4 "i+1")
                       ((then (expand length 1)(assert))
                        (then (expand nth 4 1)))))))))))
               (then (assert)
                (spread (inst 3 "0")
                 ((then (expand length 1)(assert))
                  (then (expand nth 3))))))))
            (then (assert)
             (spread (case "cdr(cdr(p)) = null")
              ((then (lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert)(lemma "cdr_of_sorted_is_sorted")(inst -1 "cdr(p)")(assert)(lemma "cons_smaller_to_sorted_is_sorted")(inst -1 "cdr(cdr(p))" "add_mono(car(p),car(cdr(p)))")(assert)(expand add_mono -1 1)(replace -4)(expand is_sorted? -3)
                (spread (inst -3 "0")
                 ((then (expand length 1)(assert))
                  (spread (split -3)
                   ((then (expand length 1)(expand length 1)(assert))
                    (then (expand nth -1)(expand nth -1)(lemma "constant_doesnt_matter")(inst -1 "car(cdr(p))" "(# C := car(cdr(p))`C + car(p)`C, alpha := car(cdr(p))`alpha #)" "car(cdr(cdr(p)))")(assert)(hide -1)(hide -1)(inst -4 "cons(add_mono(car(p), car(cdr(p))), cdr(cdr(p)))")(expand length -4)(expand length -5)(assert)
                     (spread (inst -4 "j")
                      ((then (typepred "j")(expand sortedsimplify -1))
                       (then (skeep)
                        (spread (inst 3 "i+1")
                         ((then (typepred "i")(expand length -1)(expand length 1)(expand length 1)(assert))
                          (then (expand nth 3 1)(expand nth -4 1)(lift-if -4)
                           (spread (split -4)
                            ((then (flatten)(expand nth 4 1)(assert))
                             (then (flatten)(expand add_mono -2 1)(replace -5)(expand nth 3 1)(assert))))))))))))))))
               (then (replace -1)(expand sortedsimplify 2)(typepred "j")(expand sortedsimplify -1)(expand sortedsimplify -1)(assert)(expand length -1)(expand length -1)(expand nth 2 2)(assert)(expand add_mono 2)
                (spread (inst 2 "0")
                 ((then (expand length 1)(assert))
                  (then (expand nth 2)))))))))))
         (then (assert)(inst 1 "j")(typepred "j")(expand sortedsimplify -1)))))
      (then (skeep)(expand length -1)(assert)))))
   (then (skeep)(inst -1 "length(p)" "p"))))
QED simplify_alpha

%-------------------------------------------
% @formula: simplified 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
simplified : PROOF
(spread (case "FORALL (n:nat, p: MultPoly | is_sorted?(p)): length(p) = n IMPLIES simplified?(sortedsimplify(p)) = TRUE")
  ((then (hide 2 )
    (spread (induct "n")
     ((then (lemma "leq_total_preorder"))
      (then (lemma "leq_total_preorder"))
      (then (skeep)(skeep)(expand sortedsimplify 1)
       (spread (split 1)
        ((then (flatten)
          (spread (split)
           ((then (flatten)
             (spread (split)
              ((then (flatten)(typepred "p")(expand is_sorted? -1)
                (spread (inst -1 "0")
                 ((then (expand length 1)(assert))
                  (then (expand length -1)(assert)(expand length -1)(expand nth -1)(expand nth -1)(assert)(expand length -1)(lift-if -1)
                   (spread (split -1)
                    ((then (flatten)(assert)(assert)(lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert)(inst -3 "cdr(p)")(expand length -4)(assert)(lemma "cons_smaller_simplify")
                      (spread (inst -1 "sortedsimplify(cdr(p))" "car(p)")
                       ((then (lemma "simplify_cons")(inst -1 "cdr(p)")(assert)(lemma "sorted_simp_is_sorted")(inst -1 "cdr(p)"))
                        (then (lemma "car_equal_simplify")(inst -1 "cdr(p)")(lemma "constant_doesnt_matter_last")(inst -1 "car(p)" "car(cdr(p))" "car(sortedsimplify(cdr(p)))")(assert)))))
                     (then (flatten)(assert)(lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert)(inst -4 "cdr(p)")(expand length -5)(assert)(lemma "leq_simplify")(inst -1 "cdr(p)" "car(p)")(assert)(lemma "cons_smaller_to_sorted_is_sorted")(inst -1 "sortedsimplify(cdr(p))" "car(p)")(lemma "simplify_cons")(inst -1 "cdr(p)")(assert)(lemma "sorted_simp_is_sorted")(inst -1 "cdr(p)")(assert)(lemma "cons_smaller_simplify")(inst -1 "sortedsimplify(cdr(p))" "car(p)")(assert)(lemma "not_equal_simplify")(inst -1 "cdr(p)" "car(p)")(assert))))))))
               (then (flatten)
                (spread (case "cdr(cdr(p)) = null")
                 ((then (lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert)(lemma "cdr_of_sorted_is_sorted")(inst -1 "cdr(p)")(assert)(lemma "cons_smaller_to_sorted_is_sorted")(inst -1 "cdr(cdr(p))" "add_mono(car(p),car(cdr(p)))")(assert)(expand add_mono -1)(replace -4)(lemma "constant_doesnt_matter")(expand is_sorted? -4)
                   (spread (inst -4 "0")
                    ((then (expand length 1)(assert))
                     (then (expand length -4)(expand length -4)(assert)(expand nth -4)(expand nth -4)(inst -1 "car(cdr(p))" "(# C := car(cdr(p))`C + car(p)`C, alpha := car(cdr(p))`alpha #)" "car(cdr(cdr(p)))")(assert)(expand add_mono 2)(inst -6 "cons((# C := car(cdr(p))`C + car(p)`C, alpha := car(p)`alpha #), cdr(cdr(p)))")(expand length -6)(expand length -7)(expand length -7)(assert)))))
                  (then (replace -1)(expand sortedsimplify 1)(expand simplified? 1)(expand length 1)(expand length 1))))))))
            (then (flatten)(assert)(typepred "p")(expand simplified? 1)(expand length 1)(assert)(expand length 1)))))
         (then (flatten)(expand length -3)(assert)))))
      (then (skeep)(expand length -1)(lift-if -1)
       (spread (split )
        ((then (flatten)(assert))
         (then (expand sortedsimplify)(assert)(expand simplified?))))))))
   (then (skeep)(inst -1 "length(p)" "p"))))
QED simplified

%-------------------------------------------
% @formula: simplify_Unif 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
simplify_Unif : PROOF
(spread (case "FORALL (n:nat, p: MultPoly | is_sorted?(p) AND Unif?(p)): length(p) = n IMPLIES Unif?(sortedsimplify(p))")
  ((then (hide 2)
    (spread (induct "n")
     ((then (lemma "leq_total_preorder"))
      (then (lemma "leq_total_preorder"))
      (then (flatten)
       (spread (split 2)
        ((then (flatten)
          (spread (inst -2 "cdr(p)")
           ((then (lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert)(typepred "p")(expand Unif? 1)(skeep)(expand Unif? -2)
             (spread (inst -2 "i+1" "j!1+1")
              ((then (expand length 1)(assert))
               (then (expand length 1)(assert))
               (then (expand nth -2)))))
            (then (assert)(typepred "p")(lemma "Unif_cons")
             (spread (inst -1 "car(p)" "sortedsimplify(cdr(p))")
              ((then (assert)(lemma "simplify_cons")(inst -1 "cdr(p)")(assert))
               (then (lemma "car_equal_simplify")
                (spread (inst -1 "cdr(p)")
                 ((then (lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert))
                  (then (replace -1)(expand Unif? -4)
                   (spread (inst -4 "0" "1")
                    ((then (expand length 1)(assert))
                     (then (expand length 1)(assert)(expand length 1)(assert))
                     (then (expand nth -4)(expand nth -4)(assert))))))))))))))
         (then (flatten)
          (spread (case "cdr(cdr(p)) = null")
           ((then (lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert)(lemma "cdr_of_sorted_is_sorted")(inst -1 "cdr(p)")(assert)(lemma "cons_smaller_to_sorted_is_sorted")(inst -1 "cdr(cdr(p))" "add_mono(car(p),car(cdr(p)))")(assert)(expand add_mono -1 1)(replace -4)(lemma "constant_doesnt_matter")(inst -1 "car(cdr(p))" "(# C := car(cdr(p))`C + car(p)`C, alpha := car(cdr(p))`alpha #)" "car(cdr(cdr(p)))")(expand is_sorted? -4)
             (spread (inst -4 "0")
              ((then (expand length 1)(assert))
               (spread (split -4)
                ((then (expand length 1)(expand length 1)(assert))
                 (then (expand nth -1)(expand nth -1)(assert)(hide -1)(hide -1)(typepred "p")
                  (spread (inst -7 "cons(add_mono(car(p), car(cdr(p))), cdr(cdr(p)))")
                   ((then (expand Unif? 1)(skeep)(hide -1)(hide -2)(hide -2)(expand add_mono)(replace -2)(hide -2)(hide -2)(expand Unif? -1)
                     (spread (inst -1 "i+1" "j!1 + 1")
                      ((then (typepred "i")(expand length -1)(expand length 1)(expand length 1)(assert))
                       (then (expand length 1)(typepred "j!1")(expand length -1)(expand length 1)(assert))
                       (then (expand nth -1)(expand nth 1)(lift-if 1)
                        (spread (split 1)
                         ((then (flatten)(expand nth -2)(assert))
                          (then (flatten)(lift-if 2)
                           (spread (split 2)
                            ((then (flatten)(expand nth -1)(assert))
                             (then (flatten)(expand nth -2)(assert)))))
                          (then (assert)(flatten)(lift-if 1)(assert)(split 1))))))))
                    (then (expand length -6)(expand length -7))))))))))
            (then (replace -1)(expand sortedsimplify 1)(expand Unif? 1)(skeep)(typepred "i")(typepred "j!1")(expand length -1)(expand length -1)(expand length -2)(expand length -2)(expand nth 1)(assert))))))))
      (then (flatten)(expand sortedsimplify 2)(assert)(split 2))
      (then (skeep)(skeep)(expand length -2)(lift-if -2)(assert)(split -2))
      (then (skeep)(expand length)(lift-if -1)
       (spread (split -1)
        ((then (flatten)(assert))
         (then (expand sortedsimplify)(assert))))))))
   (then (skeep)(inst -1 "length(p)" "p"))))
QED simplify_Unif

%-------------------------------------------
% @formula: allnonzero_cdr 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
allnonzero_cdr : PROOF
(then (skeep)(expand allnonzero?)(assert)
  (spread (case "cdr(p) = null")
   ((spread (split 3)
     ((then (skeep)(assert)
       (spread (inst 1 "i+1")
        ((then (expand length 1)(cancel-add 1)(typepred "i"))
         (then (expand nth 1)))))))
    (then (assert)(split -2))
    (then (assert)))))
QED allnonzero_cdr

%-------------------------------------------
% @formula: all_nonzero 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
all_nonzero : PROOF
(spread (induct "p")
  ((then (skeep)(expand allnonzero 1)
    (spread (split 1)
     ((then (flatten)(expand allnonzero? 2)(assert)
       (spread (split 2)
        ((then (skeep)
          (spread (case "i = 0")
           ((then (expand allnonzero? -2)(assert)
             (spread (split -2)
              ((spread (inst 1 "i-1")
                ((then (typepred "i")(expand length -1)(assert))
                 (then (expand nth -1))))
               (then (flatten)(assert)(split -1))
               (then (assert)(typepred "i")(expand length -1)(expand length -1)(assert)))))
            (then (replace -1)(expand nth -2))))))))
      (then (flatten)))))
   (then (expand allnonzero)(expand allnonzero?))))
QED all_nonzero

%-------------------------------------------
% @formula: allnonzero_alpha 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
allnonzero_alpha : PROOF
(spread (induct "p")
  ((then (skeep)(skeep)
    (spread (case "j=0")
     ((then (expand nth 2)(assert)
       (spread (case "cons2_var = null")
        ((then (assert)(expand nth 4 1)(inst -1 "j-1")(assert)
          (spread (case "cons1_var`C = 0")
           ((then (expand allnonzero 5)(assert)(skeep)
             (spread (inst 5 "k+1")
              ((then (typepred "k")(expand allnonzero 1)(expand length 1)(assert))
               (then (expand nth 5 2)(typepred "j")(expand length -1)(assert)))))
            (then (expand allnonzero 4)(assert)(skeep)(typepred "k")
             (spread (inst 4 "k")
              ((then (expand allnonzero 1))
               (then (typepred "j")(expand length -1)(assert))))))))
         (then (replace -1)(expand allnonzero 3)(assert)(expand allnonzero 3)(expand nth 3 1)(typepred "j")(expand length -1)(expand length -1)(assert)))))
      (then (replace -1)(expand nth 1)(expand nth 2 1)(expand allnonzero 2)(assert)
       (spread (inst 2 "0")
        ((then (expand allnonzero 1)(expand length 1)(assert))
         (then (expand nth 2))))))))
   (then (assert))
   (then (assert))))
QED allnonzero_alpha

%-------------------------------------------
% @formula: allnonzero_alpha_reverse 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
allnonzero_alpha_reverse : PROOF
(spread (induct "p")
  ((then (skeep)
    (spread (case "cons2_var = null")
     ((then (assert)
       (spread (case "allnonzero(cons2_var)=null")
        ((then (skeep)(typepred "k")(expand allnonzero -1)(lift-if -1)
          (spread (split -1)
           ((then (flatten)(expand length -1)(expand allnonzero 4)(assert)
             (spread (case "k=0")
              ((then (expand nth 5 3)(assert)(inst -2 "k-1")(skeep)
                (spread (inst 6 "j+1")
                 ((then (expand length 1)(assert))
                  (then (expand nth 6 1)(assert)(expand nth 6 1)))))
               (then (expand nth 4 3)(assert)
                (spread (inst 4 "0")
                 ((then (expand length 1)(assert))
                  (then (expand nth 4))))))))
            (then (flatten)(expand allnonzero 3)(assert)(inst -3 "k")(skeep)
             (spread (inst 4 "j+1")
              ((then (expand length 1)(assert))
               (then (expand nth 4 1)(assert)(expand nth 4 1))))))))
         (then (skeep)(typepred "k")(expand allnonzero -1)(lift-if -1)
          (spread (split -1)
           ((then (flatten)(expand length -1)(expand length -1)(assert)(expand nth 3 3)(expand allnonzero 3)
             (spread (inst 3 "0")
              ((then (expand length 1)(assert))
               (then (expand nth 3)))))
            (then (flatten)(expand length  -2)(assert))))))))
      (then (skeep)(typepred "k")(expand allnonzero -1)(lift-if -1)
       (spread (split -1)
        ((then (flatten)(expand length -1)(expand allnonzero -1)(assert)(expand length -1)(expand nth 2 3)(assert)(expand allnonzero 2)
          (spread (inst 2 "0")
           ((then (expand length 1)(assert))
            (then (assert)(expand nth 2)))))
         (then (flatten)(expand allnonzero -2)(assert)(expand length -2)(assert))))))))
   (then (assert))
   (then (assert))))
QED allnonzero_alpha_reverse

%-------------------------------------------
% @formula: allnonzero_length 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
allnonzero_length : PROOF
(spread (induct "p")
  ((then (skeep)(expand allnonzero 1)(lift-if 1)
    (spread (split 1)
     ((then (flatten)(expand length 2)(assert))
      (then (flatten)(expand length 1 2)(assert)))))
   (then (expand allnonzero)(assert))))
QED allnonzero_length

%-------------------------------------------
% @formula: allnonzero_sorted 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
allnonzero_sorted : PROOF
(spread (induct "p")
  ((then (lemma "leq_total_preorder"))
   (then (assert)(skeep)(lemma "leq_total_preorder"))
   (then (skeep)(lemma "cdr_of _sorted_is_sorted")(lemma "cdr_of_sorted_is_sorted")(inst -1 "cons(cons1_var,cons2_var)")(assert)(expand is_sorted? 1)(skeep)
    (spread (case "cons2_var = null")
     ((spread (case "k=0")
       ((then (expand nth 3)(assert)(expand allnonzero 3)(assert)(lift-if 3)
         (spread (split 3)
          ((then (flatten)(expand is_sorted? -2)(inst -2 "k-1")(expand allnonzero -4)(assert)(expand length -3)(assert))
           (then (flatten)(expand is_sorted? -3)
            (spread (inst -3 "k")
             ((then (typepred "k")(expand allnonzero -1)(assert))
              (then (expand allnonzero -5)(assert)(assert)(expand nth  -3))))))))
        (then (replace -1)(expand nth 2)(expand nth 2)(expand allnonzero 2)(lift-if 2)
         (spread (split 2)
          ((then (flatten)(lemma "allnonzero_alpha_reverse")
            (spread (inst -1 "cons2_var")
             ((then (assert))
              (spread (case "allnonzero(cons2_var)=null")
               ((then (assert)
                 (spread (inst -1 "0")
                  ((then (expand length 1)(assert))
                   (then (expand nth -1 3)(skeep)(lemma "is_sorted_implies_monotone")(inst -1 "cons(cons1_var,cons2_var)")(assert)
                    (spread (inst -1 "j+1" "0")
                     ((then (expand length 1)(assert))
                      (then (expand nth -1)(assert)(lemma "constant_doesnt_matter_last")(inst -1 "cons1_var" "nth(cons2_var, j)" "car(allnonzero(cons2_var))")(assert))))))))
                (then (expand allnonzero -7)(assert)(expand length -7)(expand length -7)(assert)))))))
           (then (flatten)
            (spread (case "allnonzero(cons2_var) = null")
             ((then (expand is_sorted? -4)
               (spread (inst -4 "0")
                ((then (expand length 1)(assert))
                 (then (assert)
                  (spread (split -4)
                   ((then (expand length 1)(expand allnonzero -5)(expand length -5))
                    (then (expand nth -1)(expand nth -1))))))))
              (then (assert)(expand allnonzero -7)(expand length -7)(assert))))))))))
      (then (typepred "k")(lemma "allnonzero_length")(inst -1 "cons(cons1_var,cons2_var)")(assert)(expand length -1 2)(expand length -1 2)(assert)))))
   (then (expand is_sorted?)(assert)(expand allnonzero)(assert))))
QED allnonzero_sorted

%-------------------------------------------
% @formula: allnonzero_simp 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
allnonzero_simp : PROOF
(spread (induct "p")
  ((then (skeep)
    (spread (case "i=0")
     ((then (expand nth -1)(assert)(lift-if -1)
       (spread (split -1)
        ((then (flatten)(expand allnonzero -1)(lift-if -1)
          (spread (split -1)
           ((then (flatten)(expand simplified? -3)
             (spread (split -3)
              ((then (flatten)
                (spread (split -1)
                 ((spread (inst -1 "i-1" "j-1")
                   ((then (assert))
                    (then (assert)))))))
               (then (typepred "i")(expand allnonzero -1)(assert)(expand length -1)
                (spread (split -2)
                 ((then (replace -1)(assert)(typepred "j")(expand allnonzero -1)(expand length -1)(replace -2)(assert))
                  (then (expand length -2)(assert))))))))
            (then (flatten)(expand simplified? -4)
             (spread (split -4)
              ((then (flatten)
                (spread (split -1)
                 ((spread (inst -1 "i" "j")
                   ((then (typepred "i")(expand allnonzero -1)(assert))
                    (then (typepred "j")(expand allnonzero -1)(assert))
                    (then (assert)(expand nth -1)))))))
               (then (typepred "i")(expand allnonzero -1)(assert)(expand length -1)(assert))))))))
         (then (flatten)(expand allnonzero -2)(assert)(lift-if -2)
          (spread (split -2)
           ((then (flatten)(lemma "allnonzero_alpha_reverse")
             (spread (inst -1 "cons2_var")
              ((then (typepred "i")(expand length -1)(expand allnonzero -1)(assert)(expand allnonzero -1)(expand length -1)(assert))
               (then (assert)
                (spread (case "allnonzero(cons2_var) = null")
                 ((then (assert)(inst -1 "i-1")(skeep)(expand simplified? -6)
                   (spread (split -6)
                    ((then (flatten)
                      (spread (split -1)
                       ((spread (inst -1 "j!1+1" "0")
                         ((then (expand length 1)(assert))
                          (then (expand length 1)(assert))
                          (then (assert)(expand nth 1)(assert)))))))
                     (then (expand length -1)(expand length -1)(lift-if -1)(assert)
                      (spread (split -1)
                       ((then (flatten)(assert))
                        (then (typepred "i")(expand allnonzero -1)(expand allnonzero -1)(assert)(expand length -1)(expand length -1)(assert))))))))
                  (then (typepred "i")(expand allnonzero -1)(expand length -1)(expand length -1)(assert))))))))
            (then (flatten)(expand simplified? -5)(assert)
             (spread (split -5)
              ((then (flatten)
                (spread (split -1)
                 ((spread (inst -1 "0" "i")
                   ((then (expand length 1)(assert))
                    (then (typepred "i")(expand allnonzero -1))
                    (then (assert)(expand nth -1)(assert)))))))
               (then (typepred "j")(expand allnonzero -1)
                (spread (split -2)
                 ((then (replace -1)(assert)(typepred "i")(expand allnonzero -1)(replace -2)(assert))
                  (then (expand length -2)(assert))))))))))))))
      (then (expand nth -2)(assert)(expand allnonzero -2)(lift-if -2)
       (spread (split -2)
        ((then (flatten)(lemma "allnonzero_alpha_reverse")
          (spread (inst -1 "cons2_var")
           ((then (typepred "j")(expand allnonzero -1)(assert)(expand length -1)(expand length -1)(lift-if -1)
             (spread (split -1)
              ((then (flatten)(hide -1)(lemma "allnonzero_length")(inst -1 "cons2_var")(expand length -1)(assert))
               (then (flatten)(assert)))))
            (spread (case "allnonzero(cons2_var)=null")
             ((then (assert)(inst -1 "j-1")(skeep)(expand simplified? -6)
               (spread (split -6)
                ((then (flatten)
                  (spread (split -1)
                   ((spread (inst -1 "0" "j_1+1")
                     ((then (expand length 1)(assert))
                      (then (expand length 1)(assert))
                      (then (assert)(expand nth 1)(assert)))))))
                 (then (expand length -1)(lemma "allnonzero_length")(inst -1 "cons2_var")(expand length -1 1)(assert)))))
              (then (typepred "j")(expand allnonzero -1)(assert)(expand length -1)(expand length -1)(assert)))))))
         (then (flatten)(expand simplified? -5)
          (spread (split -5)
           ((then (flatten)
             (spread (split -1)
              ((spread (inst -1 "0" "j")
                ((then (assert)(expand length 1)(assert))
                 (then (typepred "j")(expand allnonzero -1)(assert))
                 (then (assert)(expand nth -1)))))))
            (then (typepred "i")(expand allnonzero -1)(assert)
             (spread (split -2)
              ((then (replace -1)(typepred "j")(expand allnonzero -1)(replace -2)(assert))
               (then (expand length -2)(assert))))))))))))))
   (then (flatten)(split 3))
   (then (skeep)(lemma "simplify_cdr")(inst -1 "cons(cons1_var,cons2_var)")(assert)(expand simplified? 1)(split 1))
   (then (expand allnonzero)(assert)(flatten))))
QED allnonzero_simp

%-------------------------------------------
% @formula: cutting_length 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
cutting_length : PROOF
(spread (case "FORALL (l: list[nat], n:nat): length(l) = n IMPLIES length(l) >= length(cutting(l))")
  ((then (hide 2)
    (spread (induct "n")
     ((then (skeep)(skeep)(expand cutting 1)(lift-if 1)(assert)
       (spread (split 1)
        ((then (flatten)(lemma "rdc_rac[nat]")(inst? -1)(lemma "length_append[nat]")(inst?)(replace -2)(replace -1)(assert)(inst -4 "rdc(l)")(assert)))))
      (then (skeep)(expand length -1)(lift-if)
       (spread (split -1)
        ((then (flatten)(assert))
         (then (expand cutting 1)(assert))))))))
   (then (skeep)(inst -1 "l" "length(l)"))))
QED cutting_length

%-------------------------------------------
% @formula: cutting_last 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
cutting_last : PROOF
(spread (case "FORALL (l: list[nat], n:nat): length(l) = n IMPLIES (cutting(l) = null OR last(cutting(l)) /= 0)")
  ((then (hide 2)
    (spread (induct "n")
     ((then (skeep)(assert))
      (then (skeep)(assert))
      (then (skeep)(skeep)(expand cutting 1)(assert)(lift-if 1)(assert)
       (spread (split 1)
        ((then (inst -1 "rdc(l)")(lemma "rdc_rac[nat]")(inst?)(lemma "length_append[nat]")(inst?)(replace -2)(replace -4)(expand length -1 2)(assert)(grind))
         (then (flatten)(inst -2 "rdc(l)")(lemma "rdc_rac[nat]")(inst? -1)(lemma "length_append[nat]")(inst?)(replace -2)(replace -5)(expand length -1 2)(expand length -1 2)(assert)(assert)(grind)))))
      (then (skeep)(expand length -1)(lift-if)
       (spread (split -1)
        ((then (flatten)(assert))
         (then (expand cutting)(assert))))))))
   (then (skeep)(inst -1 "l" "length(l)")(assert))))
QED cutting_last

%-------------------------------------------
% @formula: mv_cut_length 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
mv_cut_length : PROOF
(spread (case "FORALL(n:nat,p:MultPoly): length(p)=n IMPLIES length(p)=length(mv_cut(p))")
  ((then (hide 2)
    (spread (induct "n")
     ((then (skeep)(skeep)
       (spread (case "p=null")
        ((then (flatten)(assert)
          (spread (split 2)
           ((then (flatten)(expand "length" 2 2)(expand "length" 2 1)(inst -1 "cdr(p)")(assert)(expand "length" -1))
            (then (flatten)(expand "length" 1 2)(expand "length" 1 1)(inst -3 "cdr(p)")(assert)(expand "length" -3)))))
         (then (expand "mv_cut" 2 1)(lift-if )(split 2))
         (then (replace -1)(expand "length" -3)(assert)))))
      (then (skeep)(grind)(expand "mv_cut" 1 1)(assert)(expand "length" -1)(lift-if -1)
       (spread (split -1)
        ((then (flatten)(assert))
         (then (assert))))))))
   (then (skeep)(inst -1 "length(p)" "p"))))
QED mv_cut_length

%-------------------------------------------
% @formula: max_length_cut 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_length_cut : PROOF
(spread (induct "p")
  ((then (skeep)(expand mv_cut 1)(lift-if)
    (spread (split)
     ((then (flatten)(expand max_length 2 2)(assert)(expand max_length 2 1)(assert)(expand max 2 2)(assert)(lift-if 2)
       (spread (split 2)
        ((then (flatten)(assert))
         (then (flatten)(assert)))))
      (then (flatten)(expand max_length 1)(typepred "standard_form(cons1_var`alpha)")(hide -1)(hide -1)(assert)
       (spread (case "length(cutting(cons1_var`alpha))< max_length(mv_cut(cons2_var))")
        ((then (expand max 2 2)(assert)(lemma "cutting_length")(inst -1 "cons1_var`alpha")(assert))
         (then (expand max 1 2)(assert))))))))
   (then (expand mv_cut)(assert))))
QED max_length_cut

%-------------------------------------------
% @formula: mv_cut_last_nonzero 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
mv_cut_last_nonzero : PROOF
(spread (induct "p")
  ((then (skeep)(assert)(grind))
   (then (skeep)(skeep)
    (spread (case "j=0")
     ((spread (case "cons2_var = null")
       ((then (assert)
         (spread (inst -1 "j-1")
          ((then (typepred "j")(lemma "mv_cut_length")(inst -1 "cons(cons1_var,cons2_var)")(expand length -1 1)(assert)(grind))
           (then (expand nth 3)(expand mv_cut 3)(assert)(expand nth -2)(expand mv_cut -2)(assert)))))
        (then (expand nth)(assert)(replace -1)(expand mv_cut 2)(assert)(expand mv_cut 2)(assert)(grind)(expand nth)(typepred "j")(grind))))
      (then (replace -1)(expand nth 1)(expand nth -3)(expand mv_cut -3)(assert)(lift-if -3)
       (spread (split -3)
        ((then (flatten)(expand mv_cut 2)(assert)(lift-if 2)(assert)(grind))
         (then (flatten)(lemma "cutting_last")(inst? -1)(assert)(expand mv_cut 1)(lift-if)(assert))))))))
   (then (assert))
   (then (assert))
   (then (assert))))
QED mv_cut_last_nonzero

%-------------------------------------------
% @formula: lft_max_0 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_max_0 : PROOF
(then (skeep)(assert)(skeep)(lemma "lft_length_nth")
  (spread (case "p=null")
   ((spread (inst? -1)
     ((then (flatten)(assert))
      (then (typepred "j")(lemma "Lft_length")(inst? -1)(assert))
      (then (expand length -1)(lift-if -1)(split -1))))
    (then (expand lft 1)(expand length 1)(assert)))))
QED lft_max_0

%-------------------------------------------
% @formula: lft_minlength 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_minlength : PROOF
(then (skeep)(assert)(flatten)(skeep)(expand minlength? 2)(lemma "Lft_length")(inst -1 "p" "max_length(p)")(expand length -1)(lift-if -1)(assert)
  (spread (split -1)
   ((then (lemma "lft_n_last")(inst -1 "p" "max_length(p)" "j")(assert)
     (spread (case "max_length(p) = 0")
      ((then (assert)(lemma "lft_length_nth")(inst -1 "p" "max_length(p)" "j")(expand length -1)(lift-if -1)(assert)(split -1)
        (spread (grind)
         ((then (flatten)(hide -1)(inst 3 "j")(assert)))))
       (then (replace -1)(expand lft 1)(assert)(expand length 1)(assert)(grind)))))
    (then (flatten)(lemma "lft_Unif")(inst -1 "p")(assert)(split 2))
    (then (flatten)(assert)(hide -1)(split 3))
    (then (flatten)(assert)))))
QED lft_minlength

%-------------------------------------------
% @formula: lft_all_null 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_all_null : PROOF
(then (skeep)(assert)(flatten)(expand minlength?)(lemma "Lft_length")(inst -1 "p" "max_length(p)")(expand length -1)(lift-if -1)
  (spread (split -1)
   ((then (flatten)(hide -1)(assert)(lemma "lft_length_nth")(inst? -1)(lemma "max_length_is_nth")(inst -1 "p")(expand length -1)(assert)(skeep)(lift-if -1)(assert)
     (spread (split -1)
      ((then (flatten)(lemma "max_length_is_nth")(inst? -1)(expand length -1)(assert)(skeep)(lift-if -1)(assert)
        (spread (inst -4 "j!1")
         ((then (typepred "j!1")(lemma "Lft_length")(inst? -1)(assert))
          (then (split -1))
          (then (assert)))))
       (then (flatten)(assert)(replace -2)(expand length -3)(assert)(lemma "Lft_length")(inst? -1)(assert)(split 2)
        (spread (grind)
         ((then (flatten)(skeep)(inst -4 "i")(lift-if -4)
           (spread (split -4)
            ((then (flatten)(assert))
             (then (flatten)))))))))))
    (then (flatten -1)(assert)))))
QED lft_all_null

%-------------------------------------------
% @formula: lft_mv_cut 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_mv_cut : PROOF
(then (skeep)(assert)
  (spread (case "mv_cut(p) = null")
   ((then (lemma "max_length_is_nth")
     (spread (inst -1 "mv_cut(p)")
      ((then (expand lft)(expand length 4)(assert))
       (then (case "mv_cut(p) = null"))
       (then (lemma "max_length_is_max")
        (spread (case "FORALL(j: below(length(mv_cut(p)))): null?(nth(mv_cut(p),j)`alpha)")
         ((then (skeep)(skeep)(lemma "mv_cut_last_nonzero")(inst? -1)(assert)(inst -1 "j!1")(hide -2)
           (spread (split -1)
            ((then (expand length -2 )(lift-if -2)
              (spread (split -2)
               ((then (flatten)(lemma "lft_minlength")(inst -1 "mv_cut(p)")(assert)(inst 1 "j!1")(assert))
                (then (flatten)(lemma "max_length_is_max")(inst -1 "mv_cut(p)" "j")(expand length -1)(assert)))))
             (then (expand length -2)(assert)(lemma "lft_max_0")(inst? -1)(assert)(lemma "Lft_length")(inst? -1)(expand length -1)(lift-if -1)
              (spread (split -1)
               ((then (flatten)(skeep)(inst -1 "i")(assert))
                (then (flatten)(hide -1)(expand minlength? 4)(assert)(split 4))
                (then (flatten)(assert))))))))
          (then (lemma "lft_all_null")
           (spread (inst -1 "mv_cut(p)")
            ((then (assert))
             (then (assert)(lemma "Lft_length")(inst? -1)(skeep)(inst -2 "j")))))))))))
    (then (replace -1)(expand lft)(assert)(expand minlength?)))))
QED lft_mv_cut

%-------------------------------------------
% @formula: minlength_cdr 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
minlength_cdr : PROOF
(then (skeep)
  (spread (case "cdr(p) = null")
   ((then (lemma "lft_mv_cut")
     (spread (inst -1 "cdr(p)")
      ((then (assert))
       (then (assert)))))
    (then (replace -1)(expand mv_cut)(expand lft)(assert)(expand minlength? 1)))))
QED minlength_cdr

%-------------------------------------------
% @formula: minlength_simplify 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
minlength_simplify : PROOF
(then (skeep)(expand minlength? -3)(assert)
  (spread (split -3)
   ((then (flatten)(assert)
     (spread (split -1)
      ((then (lemma "simplify_Unif")(inst? -1)(assert)(skeep)(lemma "simplify_alpha_reverse")(inst -1 "p" "j")(skeep)(inst 1 "j_1")(assert))
       (then (flatten)(split 2))
       (then (flatten)(skeep)(hide 1)(skeep)(expand minlength? 2)(lemma "simplify_cons")(inst? -1)(assert)(split 2)))))
    (then (flatten)(skeep)(lemma "simplify_Unif")
     (spread (inst -1 "p")
      ((then (assert)(expand Unif? 1)(skeep)(copy -2)(inst -1 "i!1")(inst -3 "j")(expand length 1)(assert))
       (then (assert)(lemma "simplify_alpha")(inst -1 "p" "i")(skeep)(inst -4 "i_1")(assert)))))
    (then (lemma "simplify_cons")(inst -1 "p")(assert)(expand minlength? 1)(split 1)))))
QED minlength_simplify

%-------------------------------------------
% @formula: lft_sorted 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_sorted : PROOF
(spread (induct "p")
  ((then (skeep)(lemma "leq_total_preorder"))
   (then (skeep)(skeep)(lemma "leq_total_preorder"))
   (then (skeep)(skeep)
    (spread (case "cons2_var = null")
     ((then (assert)(lemma "cdr_of_sorted_is_sorted")(inst -1 "cons(cons1_var,cons2_var)")(assert)
       (spread (split -2)
        ((then (expand Unif? 1)(skeep)(expand Unif? -2)
          (spread (inst -2 "i+1" "j+1")
           ((then (expand length 1)(assert))
            (then (expand length 1)(assert))
            (then (expand nth -2)))))
         (then (expand lft 2)(assert)
          (spread (split 2)
           ((then (flatten)(hide 1)
             (spread (split 1)
              ((then (flatten)(inst -1 "n")(lemma "cons_smaller_to_sorted_is_sorted")(inst -1 "lft(cons2_var)(n)" "cons1_var")(assert)(lemma "Lft_length")(inst -1 "cons2_var" "n")(expand length -1)(lift-if)
                (spread (split -1)
                 ((then (flatten)(hide -1)(assert)(expand lft 2)(lift-if 2)(assert)
                   (spread (split 2)
                    ((then (flatten)(hide 1)(expand Unif? -3)
                      (spread (inst -3 "0" "1")
                       ((then (expand length 1)(assert))
                        (then (expand length 1)(assert)(expand length 1)(assert))
                        (then (expand nth -3)(expand nth -3)(replace -3)(assert)(expand is_sorted? -4)
                         (spread (inst -4 "0")
                          ((then (expand length 1)(assert))
                           (then (expand nth -4)(expand nth -4)(expand length 6)(expand length 6)(assert))))))))
                     (then (flatten)(expand length -1)(assert)))))
                  (then (flatten)(assert)))))
               (then (flatten)(inst -3 "n")(lemma "Lft_length")(inst? -1)(expand length -1)(lift-if -1)
                (spread (split -1)
                 ((then (flatten)(hide -1)(lemma "cons_smaller_to_sorted_is_sorted")
                   (spread (inst -1 "lft(cons2_var)(n)" "(# C := cons1_var`C, alpha := append(cons1_var`alpha, (: 0 :)^(n - length(cons1_var`alpha))) #)")
                    ((then (typepred "n")(expand max_length -1)(assert))
                     (then (assert)(hide 3)(expand lft 1)(lift-if 1)
                      (spread (split 1)
                       ((then (flatten)(hide 1)
                         (spread (split 1)
                          ((then (flatten)(expand Unif? -5)
                            (spread (inst -5 "0" "1")
                             ((then (expand length 1)(assert))
                              (then (expand length 1)(expand length 1)(assert))
                              (then (expand nth -5)(expand nth -5)(replace -5)(assert)))))
                           (then (flatten)(expand Unif? -7)
                            (spread (inst -7 "0" "1")
                             ((then (expand length 1)(assert))
                              (then (expand length 1)(assert)(expand length 1)(assert))
                              (then (expand nth -7)(expand nth -7)(replace -7)(expand is_sorted? -8)
                               (spread (inst -8 "0")
                                ((then (expand length 1)(assert))
                                 (spread (split -8)
                                  ((then (expand length 1)(expand length 1)(assert))
                                   (then (expand nth -1)(expand nth -1)(lemma "append_leq")
                                    (spread (inst -1 "(: 0 :)^(n - length(car(cons2_var)`alpha))" "cons1_var" "car(cons2_var)")
                                     ((then (typepred "n")(lemma "max_length_is_max")
                                       (spread (inst -1 "cons(cons1_var,cons2_var)" "1")
                                        ((then (expand length 1)(assert))
                                         (then (expand nth -1)(expand nth -1)(assert)))))
                                      (then (assert)(assert))))))))))))))))
                        (then (flatten)(expand length -1)(assert))))))))
                  (then (flatten)(assert))))))))
            (then (flatten)(expand length -1)(assert))))))))
      (then (replace -1)(expand lft 1)(assert)
       (spread (split 1)
        ((then (flatten)(expand lft 2)(assert))
         (then (flatten)(expand lft 1)(assert)(expand is_sorted? 1)(assert))))))))
   (then (assert))
   (then (assert))
   (then (assert))
   (then (assert))
   (then (assert))))
QED lft_sorted

%-------------------------------------------
% @formula: lft_allnonzero 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_allnonzero : PROOF
(spread (induct "p")
  ((then (skeep)
    (spread (split -1)
     ((then (skeep)
       (spread (inst -1 "n")
        ((then (typepred "n")(expand max_length -1)(assert))
         (then (expand lft 1)
          (spread (split 1)
           ((then (flatten)
             (spread (split 2)
              ((then (flatten)(expand allnonzero? 2)
                (spread (split 2)
                 ((then (skeep)(expand nth -1)(lift-if -1)
                   (spread (split -1)
                    ((spread (inst 1 "0")
                      ((then (expand length 1)(assert))
                       (then (expand nth 1))))
                     (then (flatten)(expand allnonzero/ -1)(expand allnonzero? -2)
                      (spread (split -2)
                       ((then (inst 1 "i-1")(assert))
                        (then (flatten)(split -1))
                        (then (typepred "i")(expand length -1)(expand length -1)(assert)))))
                     (then (flatten)(expand allnonzero? -4)(split -4))))))))
               (then (hide 2)(flatten)(expand allnonzero? 1)
                (spread (split 1)
                 ((then (skeep)
                   (spread (case "i=0")
                    ((spread (inst 1 "0")
                      ((then (expand length 1)(assert))
                       (then (expand nth 1))))
                     (then (expand nth -1)(assert)(expand allnonzero? -4)
                      (spread (split -4)
                       ((then (inst 1 "i-1"))
                        (then (flatten)(split -1))
                        (then (assert)(typepred "i")(expand length -1)(expand length -1)(assert)))))
                     (then (replace -1)(expand nth -2)(expand allnonzero? -6)(split -6)))))))))))
            (then (flatten)(expand length)(assert)))))))))))
   (then (flatten)
    (spread (split 2)
     ((then (skeep)
       (spread (inst 1 "i+1")
        ((then (expand length 1)(assert))
         (then (expand nth 1)))))
      (then (split -2)))))
   (then (hide 2)(expand allnonzero?)(split 1))
   (then (expand lft)(assert)(flatten)(skeep))
   (then (assert))))
QED lft_allnonzero

%-------------------------------------------
% @formula: lft_alpha 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_alpha : PROOF
(spread (induct "p")
  ((then (skeep)(skeep)(assert)(grind))
   (then (skeep)(skeep)(typepred "n")(lemma "max_length_is_max")(inst -1 "p" "i")(assert))
   (then (skeep)(skeep)(typepred "i")(lemma "Lft_length")(inst? -1)(assert))
   (then (skeep)(skeep)(skeep)(assert)(typepred "i")(lemma "Lft_length")(inst? -1)(assert))
   (then (skeep)(skeep)
    (spread (case "cons2_var = null")
     ((then (flatten)(expand lft 3)(assert)(expand nth 3))
      (then (skeep)(assert)
       (spread (inst -1 "n")
        ((then (typepred "n")(expand max_length -1)(assert))
         (spread (case "i=0")
          ((then (flatten)(expand lft 4)(assert))
           (then (expand nth 3)(assert)(expand nth 4)(expand lft 4)(lift-if 4)(expand lft 3)(lift-if 3)(inst -1 "i-1")(assert))
           (then (expand nth 2)(assert)(expand nth 3)(expand lft 2)(lift-if 2)(split 2)))))))
      (then (skeep)(typepred "i")(expand length -1)(expand length -1)(assert)(expand nth 1)(expand lft 1)(assert)(lift-if 1)(assert)(split 1)))))
   (then (assert))
   (then (assert))))
QED lft_alpha

%-------------------------------------------
% @formula: minlength_sorted 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
minlength_sorted : PROOF
(then (skeep)(expand mv_sort)(typepred "p")(expand minlength? -2)
  (spread (split -2)
   ((then (flatten)
     (spread (split -1)
      ((then (flatten)(lemma "lft_minlength")(inst? -1)(assert)(skeep)(skeep)
        (spread (split -1)
         ((then (inst 1 "j")(assert)(lemma "max_length_Unif")(inst? -1)(skeep)(expand Unif? -1)(inst? -1))
          (then (expand minlength? -1)(lemma "Lft_length")(inst? -1)(expand length -1)(lift-if -1)
           (spread (split -1)
            ((then (flatten)(hide -1)(assert)
              (spread (split -1)
               ((then (flatten)
                 (spread (split -1)
                  ((then (flatten)(hide 1)(skeep)(lemma "bubblesort_works")(inst? -1)(flatten)(hide -1)(lemma "permutations_preserve_contents")(inst? -1)
                    (spread (inst -1 "bubblesort(lft(p)(max_length(p)))")
                     ((spread (split 1)
                       ((then (skeep)(skeep)(inst 1 "j!2")(assert))
                        (then (hide 2)(hide 2)(hide 2)(hide 2)(hide 2)(hide 2)(hide -4)(hide -4)(hide -4)(hide -4)(expand Unif?)(flatten)(skeep)(hide -1)(lemma "permutations_preserve_contents")(lemma "permutations_preserve_contents")(lemma "permutations_is_commutative")
                         (spread (inst? -1)
                          ((then (lemma "leq_total_preorder"))
                           (then (assert)
                            (spread (inst -2 "bubblesort(lft(p)(max_length(p)))" "lft(p)(max_length(p))" "i!1")
                             ((then (lemma "leq_total_preorder"))
                              (then (assert)
                               (spread (inst -3 "bubblesort(lft(p)(max_length(p)))" "lft(p)(max_length(p))" "j!2")
                                ((then (lemma "leq_total_preorder"))
                                 (then (assert)(skeep)(skeep)(inst -5 "j!3" "j!4")(assert)))))))))))))
                      (then (flatten)(split 2))
                      (then (flatten)(split 2))
                      (then (lemma "leq_total_preorder"))
                      (then (assert)(expand minlength? 5)(split 5))))))))
                (then (lemma "max_length_is_max")(inst -1 "p" "j")(expand length -1)(lemma "lft_length_nth")(inst? -1)
                 (spread (inst -3 "i")
                  ((then (typepred "i")(lemma "Lft_length")(inst? -1)(assert))
                   (then (inst -1 "i")(expand length -1)(assert))))))))
             (then (flatten)(assert)))))))))))
    (then (lemma "lft_all_null")(inst? -1)(assert)
     (spread (split -1)
      ((then (skeep)(inst -1 "j"))
       (then (lemma "bubblesort_works")(inst? -1)(flatten)(hide -1)(lemma "permutations_preserve_contents")(lemma "permutations_is_commutative")
        (spread (inst? -1)
         ((then (skeep)
           (spread (inst? -2)
            ((then (lemma "leq_total_preorder"))
             (then (inst -2 "lft(p)(max_length(p))")(assert)(skeep)(expand minlength? -4)
              (spread (split -4)
               ((then (flatten)
                 (spread (split -1)
                  ((then (flatten)
                    (spread (split -1)
                     ((then (hide 1)(hide -5)(hide 4)(hide 3)(hide 1)(flatten)
                       (spread (split 1)
                        ((then (skeep)(lemma "permutations_preserve_contents")
                          (spread (inst -1 "lft(p)(max_length(p))" "bubblesort(lft(p)(max_length(p)))" "j!1")
                           ((then (lemma "leq_total_preorder"))
                            (then (assert)(skeep)(inst 1 "j!2")(assert)))))
                         (then (expand Unif? 1)(skeep)(hide -4)(lemma "permutations_preserve_contents")(lemma "permutations_preserve_contents")
                          (spread (inst? -1)
                           ((then (lemma "leq_total_preorder"))
                            (then (inst -1 "lft(p)(max_length(p))")(assert)(skeep)
                             (spread (inst -2 "bubblesort(lft(p)(max_length(p)))" "lft(p)(max_length(p))" "j!1")
                              ((then (lemma "leq_total_preorder"))
                               (then (assert)(skeep)(expand Unif? -3)(assert)(lemma "Lft_length")(inst? -1)(expand length -1)(lift-if -1)
                                (spread (split -1)
                                 ((then (flatten)(hide -1)(assert)(inst -3 "j!2" "j!3")(assert))
                                  (then (flatten)(assert)))))))))))))))))
                   (then (inst -1 "j")(assert)))))
                (then (expand bubblesort 3)(assert))))))))
          (then (flatten)(split 2))
          (then (flatten)(split 2))
          (then (lemma "leq_total_preorder"))
          (then (assert)(expand minlength? 1)(split 1)))))))))))
QED minlength_sorted

%-------------------------------------------
% @formula: sum_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
sum_TCC1 : PROOF
(then (skeep)(assert))
QED sum_TCC1

%-------------------------------------------
% @formula: sum_TCC2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
sum_TCC2 : PROOF
(then (skeep)(grind))
QED sum_TCC2

%-------------------------------------------
% @formula: add_mono_commutative_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
add_mono_commutative_TCC1 : PROOF
(then (skeep)(typepred "m2")(assert))
QED add_mono_commutative_TCC1

%-------------------------------------------
% @formula: term_deg_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
term_deg_TCC1 : PROOF
(then (skeep)(grind))
QED term_deg_TCC1

%-------------------------------------------
% @formula: term_deg_TCC2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
term_deg_TCC2 : PROOF
(then (skeep)(lemma sum_nat)(inst?)(assert)(grind))
QED term_deg_TCC2

%-------------------------------------------
% @formula: term_deg_TCC3 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
term_deg_TCC3 : PROOF
(then (skeep)(expand length)(grind))
QED term_deg_TCC3

%-------------------------------------------
% @formula: homogen?_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
homogen?_TCC1 : PROOF
(then (skeep)(skeep)(typepred "j")(assert))
QED homogen?_TCC1

%-------------------------------------------
% @formula: homogen?_TCC2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
homogen?_TCC2 : PROOF
(then (skeep)(skeep)(typepred "j")(assert))
QED homogen?_TCC2

%-------------------------------------------
% @formula: max_deg_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_deg_TCC1 : PROOF
(then (skeep)(assert)(expand term_deg)(grind))
QED max_deg_TCC1

%-------------------------------------------
% @formula: max_deg_TCC2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_deg_TCC2 : PROOF
(then (skeep)(assert))
QED max_deg_TCC2

%-------------------------------------------
% @formula: max_deg_TCC3 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_deg_TCC3 : PROOF
(then (skeep)(expand length)(grind))
QED max_deg_TCC3

%-------------------------------------------
% @formula: max_deg_TCC4 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_deg_TCC4 : PROOF
(then (skeep)
  (spread (split)
   ((then (typepred "term_deg(p)")(grind))
    (then (grind)(lemma "sum_nat")(inst?)(assert))
    (then (typepred "v(cdr[monomial](p))")(typepred "term_deg(p)")(grind)))))
QED max_deg_TCC4

%-------------------------------------------
% @formula: max_length_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_length_TCC1 : PROOF
(then (skeep)(assert))
QED max_length_TCC1

%-------------------------------------------
% @formula: max_length_TCC2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
max_length_TCC2 : PROOF
(spread (induct "p")
  ((then (skeep)(expand length 4)(grind))
   (then (skeep)(grind))))
QED max_length_TCC2

%-------------------------------------------
% @formula: lft_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_TCC1 : PROOF
(then (lemma "max_length_a")(skeep)(inst -1 "p")(typepred "n")(assert)(mult-by -1 "length(p)")(assert))
QED lft_TCC1

%-------------------------------------------
% @formula: lft_TCC2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_TCC2 : PROOF
(then (skeep)(grind))
QED lft_TCC2

%-------------------------------------------
% @formula: lft_TCC3 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_TCC3 : PROOF
(then (skeep)(assert))
QED lft_TCC3

%-------------------------------------------
% @formula: lft_TCC4 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_TCC4 : PROOF
(then (skeep)(typepred "n")(expand "max_length" -1)(assert)(expand "length" 1)(lift-if -1)
  (spread (split -1)
   ((then (flatten)(expand "max" -1))
    (then (flatten)(lift-if 1)(assert)))))
QED lft_TCC4

%-------------------------------------------
% @formula: lft_TCC5 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_TCC5 : PROOF
(then (skeep)(expand "length_a" 2 2)(assert)
  (spread (case "p=null")
   ((then (assert)(expand "length" 3 3)(assert)(expand "length" 3 5)(assert))
    (then (expand "length" 1)(assert)))))
QED lft_TCC5

%-------------------------------------------
% @formula: lft_TCC6 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_TCC6 : PROOF
(then (skeep)(typepred "n")(expand "max_length" -1)
  (spread (case "p=null")
   ((then (assert))
    (then (expand "length" 2)(assert)))))
QED lft_TCC6

%-------------------------------------------
% @formula: lft_TCC7 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_TCC7 : PROOF
(then (skeep)
  (spread (case "p=null")
   ((then (expand "length" 4 3)(assert)(expand "length" 4 4)(assert)(expand "length_a" 4 2)(assert)(typepred "car(p)`alpha")(hide -1)
     (spread (case "n - length(car(p)`alpha) > 0")
      ((then (assert)(typepred "n")(expand "max_length" -1)(expand "max" -1)(assert)(lift-if -1)
        (spread (split -1)
         ((then (flatten)(assert))
          (then (flatten)(assert)))))
       (then (assert)))))
    (then (assert)(expand "length" 2 1)(assert)))))
QED lft_TCC7

%-------------------------------------------
% @formula: lft_example1_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_example1_TCC1 : PROOF
(then (skeep)(replace -1)(eval-formula 1))
QED lft_example1_TCC1

%-------------------------------------------
% @formula: lft_length_nth_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_length_nth_TCC1 : PROOF
(then (skeep)(typepred "j")(lemma "Lft_length")(inst?)(replace -1))
QED lft_length_nth_TCC1

%-------------------------------------------
% @formula: lft_Unif_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_Unif_TCC1 : PROOF
(then (skeep)(assert))
QED lft_Unif_TCC1

%-------------------------------------------
% @formula: lft_n_last_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_n_last_TCC1 : PROOF
(then (skeep)(expand length -1)(lift-if )(assert))
QED lft_n_last_TCC1

%-------------------------------------------
% @formula: lft_n_last_TCC2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_n_last_TCC2 : PROOF
(then (skeep)(typepred "j")(lemma "Lft_length")(inst?)(assert))
QED lft_n_last_TCC2

%-------------------------------------------
% @formula: lft_n_last_TCC3 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_n_last_TCC3 : PROOF
(then (skeep)(lemma "lft_length_nth")
  (spread (inst?)
   ((then (assert)(typepred "j")(expand length -1)(assert))
    (then (expand length -1)(lift-if -1)(assert)))))
QED lft_n_last_TCC3

%-------------------------------------------
% @formula: leq_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
leq_TCC1 : PROOF
(then (skeep)(expand "length" 5 2)(lift-if)(assert))
QED leq_TCC1

%-------------------------------------------
% @formula: IMP_bubblesort_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
IMP_bubblesort_TCC1 : PROOF
(then (expand total_preorder?)(lemma "leq_reflexive")(lemma "leq_transitive")(lemma "leq_dichotomous")(assert)(expand "preorder?" 1))
QED IMP_bubblesort_TCC1

%-------------------------------------------
% @formula: add_mono_sorted_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
add_mono_sorted_TCC1 : PROOF
(then (skeep)(typepred "m2")(assert))
QED add_mono_sorted_TCC1

%-------------------------------------------
% @formula: sortedsimplify_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
sortedsimplify_TCC1 : PROOF
(then (skeep)(assert))
QED sortedsimplify_TCC1

%-------------------------------------------
% @formula: sortedsimplify_TCC2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
sortedsimplify_TCC2 : PROOF
(then (skeep)(assert))
QED sortedsimplify_TCC2

%-------------------------------------------
% @formula: sortedsimplify_TCC3 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
sortedsimplify_TCC3 : PROOF
(then (skeep)(expand "add_mono")(replace -1)
  (spread (case "cdr(cdr(p)) = null")
   ((then (lemma "cons_smaller_to_sorted_is_sorted")(inst?)(assert)(typepred "p")(lemma "cdr_of_sorted_is_sorted")(inst -1 "p")(assert)(lemma "cdr_of_sorted_is_sorted")(inst -1 "cdr(p)")(assert)(expand is_sorted? -2)
     (spread (inst -2 "0")
      ((then (expand length 1)(assert))
       (then (expand length -2)(expand length -2)(assert)(expand length -2)(lift-if -2)(assert)(expand nth -2)
        (spread (split -2)
         ((then (flatten)(assert)(expand nth -1)(lemma "constant_doesnt_matter")(inst -1 "car(cdr(p))" "(# C:= car[monomial](cdr[monomial](p))`C +car[monomial](p)`C,alpha :=car(cdr(p))`alpha #)" "car(cdr(cdr(p)))")(assert))
          (then (flatten)(hide -1)(expand nth -1)(lemma "constant_doesnt_matter")(inst -1 "car(cdr(p))" "(# C:= car[monomial](cdr[monomial](p))`C +car[monomial](p)`C,alpha :=car(cdr(p))`alpha #)" "car(cdr(cdr(p)))")(assert))))))))
    (then (replace -1)(expand is_sorted?)(assert)))))
QED sortedsimplify_TCC3

%-------------------------------------------
% @formula: sortedsimplify_TCC4 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
sortedsimplify_TCC4 : PROOF
(then (skeep)(expand length 3 1)(expand length 3 2)(assert)(expand length 3 2)(assert))
QED sortedsimplify_TCC4

%-------------------------------------------
% @formula: sortedsimplify_TCC5 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
sortedsimplify_TCC5 : PROOF
(then (skeep)(typepred p)(lemma cdr_of_sorted_is_sorted)(inst?)(assert))
QED sortedsimplify_TCC5

%-------------------------------------------
% @formula: simplify_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
simplify_TCC1 : PROOF
(then (skeep)(expand mv_sort)
  (spread (split 2)
   ((then (flatten)(lemma "bubblesort_is_sorted")(inst? -1))
    (then (flatten)(assert)(expand is_sorted? 1)(assert)))))
QED simplify_TCC1

%-------------------------------------------
% @formula: leq_simplify_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
leq_simplify_TCC1 : PROOF
(then (skeep)(lemma "simplify_cons")(inst? -1)(assert))
QED leq_simplify_TCC1

%-------------------------------------------
% @formula: car_equal_simplify_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
car_equal_simplify_TCC1 : PROOF
(then (skeep)(lemma "simplify_cons")(inst -1 "p")(assert))
QED car_equal_simplify_TCC1

%-------------------------------------------
% @formula: allnonzero_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
allnonzero_TCC1 : PROOF
(then (skeep)(assert))
QED allnonzero_TCC1

%-------------------------------------------
% @formula: allnonzero_TCC2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
allnonzero_TCC2 : PROOF
(then (skeep)(assert)(expand length 2 2)(assert))
QED allnonzero_TCC2

%-------------------------------------------
% @formula: allnonzero_TCC3 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
allnonzero_TCC3 : PROOF
(then (skeep)(assert)(expand length 3 2)(assert))
QED allnonzero_TCC3

%-------------------------------------------
% @formula: cutting_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
cutting_TCC1 : PROOF
(then (skeep)(assert))
QED cutting_TCC1

%-------------------------------------------
% @formula: cutting_TCC2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
cutting_TCC2 : PROOF
(then (skeep)(assert))
QED cutting_TCC2

%-------------------------------------------
% @formula: cutting_TCC3 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
cutting_TCC3 : PROOF
(then (skeep)(lemma "rdc_rac[nat]")(inst?)(lemma "length_append[nat]")(inst?)(replace -2)(replace -1)(assert))
QED cutting_TCC3

%-------------------------------------------
% @formula: mv_cut_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
mv_cut_TCC1 : PROOF
(then (skeep)(expand length 2 2)(assert)(expand length_a 2 2)(assert))
QED mv_cut_TCC1

%-------------------------------------------
% @formula: mv_cut_TCC2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
mv_cut_TCC2 : PROOF
(then (skeep)(expand length 3 2)(assert)(expand length_a 3 2)(assert))
QED mv_cut_TCC2

%-------------------------------------------
% @formula: cutting_last_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
cutting_last_TCC1 : PROOF
(then (skeep)(assert))
QED cutting_last_TCC1

%-------------------------------------------
% @formula: mv_cut_last_nonzero_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
mv_cut_last_nonzero_TCC1 : PROOF
(then (skeep)(skeep)(assert))
QED mv_cut_last_nonzero_TCC1

%-------------------------------------------
% @formula: lft_max_0_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_max_0_TCC1 : PROOF
(then (skeep)(assert))
QED lft_max_0_TCC1

%-------------------------------------------
% @formula: lft_all_null_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_all_null_TCC1 : PROOF
(then (skeep)(lemma "Lft_length")(inst?)(skeep)(typepred "j")(assert))
QED lft_all_null_TCC1

%-------------------------------------------
% @formula: lft_mv_cut_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_mv_cut_TCC1 : PROOF
(then (skeep)(assert))
QED lft_mv_cut_TCC1

%-------------------------------------------
% @formula: minlength_cdr_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
minlength_cdr_TCC1 : PROOF
(then (skeep)(assert))
QED minlength_cdr_TCC1

%-------------------------------------------
% @formula: lft_alpha_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_alpha_TCC1 : PROOF
(then (skeep)(grind))
QED lft_alpha_TCC1

%-------------------------------------------
% @formula: lft_alpha_TCC2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_alpha_TCC2 : PROOF
(then (skeep)(typepred "n")(lemma "max_length_is_max")(inst -1 "p" "i")(assert))
QED lft_alpha_TCC2

%-------------------------------------------
% @formula: lft_simplify_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
lft_simplify_TCC1 : PROOF
(then (skeep)(assert))
QED lft_simplify_TCC1

%-------------------------------------------
% @formula: mv_standard_form_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
mv_standard_form_TCC1 : PROOF
(then (skeep)(expand false_counter)(assert)(lift-if 3)(assert)(expand mv_sort 3)(lift-if 3)(expand mv_standard_form? 3 1)
  (spread (split 3)
   ((then (flatten)(lemma "bubblesort_is_sorted")(inst? -1)(assert)))))
QED mv_standard_form_TCC1

%-------------------------------------------
% @formula: mv_standard_form_TCC2 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
mv_standard_form_TCC2 : PROOF
(then (skeep)(expand false_counter)(assert)(lift-if 3)(assert)(lemma "simplified")(inst? -1)(expand simplify 3)(assert)(lemma "sorted_simp_is_sorted")(inst? -1)(assert))
QED mv_standard_form_TCC2

%-------------------------------------------
% @formula: mv_standard_form_TCC3 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
mv_standard_form_TCC3 : PROOF
(then (skeep)(expand false_counter)(assert)(lift-if)(assert)(lemma "allnonzero_sorted")(inst? -1)(assert)(lemma "allnonzero_simp")(inst? -1)(assert)(lemma "all_nonzero")(inst? -1)(assert))
QED mv_standard_form_TCC3

%-------------------------------------------
% @formula: mv_standard_form_TCC4 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
mv_standard_form_TCC4 : PROOF
(then (skeep)(assert))
QED mv_standard_form_TCC4

%-------------------------------------------
% @formula: standard_cdr_TCC1 
% @theory: standard_form_mult_poly
% @status: ✅proved
%-------------------------------------------
standard_cdr_TCC1 : PROOF
(then (skeep)(assert))
QED standard_cdr_TCC1